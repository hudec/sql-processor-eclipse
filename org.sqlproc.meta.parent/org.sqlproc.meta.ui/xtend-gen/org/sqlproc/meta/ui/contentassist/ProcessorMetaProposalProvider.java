/**
 * generated by Xtext
 */
package org.sqlproc.meta.ui.contentassist;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.beans.PropertyDescriptor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmEnumerationLiteral;
import org.eclipse.xtext.common.types.JvmEnumerationType;
import org.eclipse.xtext.common.types.JvmFeature;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.conversion.IValueConverterService;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.sqlproc.meta.processorMeta.Artifacts;
import org.sqlproc.meta.processorMeta.Column;
import org.sqlproc.meta.processorMeta.DatabaseProperty;
import org.sqlproc.meta.processorMeta.DriverMethodOutputAssignement;
import org.sqlproc.meta.processorMeta.ExportAssignement;
import org.sqlproc.meta.processorMeta.ExtendedColumn;
import org.sqlproc.meta.processorMeta.ExtendedMappingItem;
import org.sqlproc.meta.processorMeta.ImportAssignement;
import org.sqlproc.meta.processorMeta.InheritanceAssignement;
import org.sqlproc.meta.processorMeta.ManyToManyAssignement;
import org.sqlproc.meta.processorMeta.MappingColumn;
import org.sqlproc.meta.processorMeta.MappingRule;
import org.sqlproc.meta.processorMeta.MetaStatement;
import org.sqlproc.meta.processorMeta.MetagenProperty;
import org.sqlproc.meta.processorMeta.PojoDefinitionModel;
import org.sqlproc.meta.processorMeta.PojogenProperty;
import org.sqlproc.meta.processorMeta.ProcessorMetaPackage;
import org.sqlproc.meta.processorMeta.ShowColumnTypeAssignement;
import org.sqlproc.meta.processorMeta.TableDefinitionModel;
import org.sqlproc.meta.ui.contentassist.AbstractProcessorMetaProposalProvider;
import org.sqlproc.meta.util.Utils;
import org.sqlproc.plugin.lib.property.ModelProperty;
import org.sqlproc.plugin.lib.property.PojoDefinition;
import org.sqlproc.plugin.lib.property.TableDefinition;
import org.sqlproc.plugin.lib.resolver.DbExport;
import org.sqlproc.plugin.lib.resolver.DbImport;
import org.sqlproc.plugin.lib.resolver.DbResolver;
import org.sqlproc.plugin.lib.resolver.PojoResolver;
import org.sqlproc.plugin.lib.util.Constants;

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
@SuppressWarnings("all")
public class ProcessorMetaProposalProvider extends AbstractProcessorMetaProposalProvider {
  public static class Founder {
    private boolean found = false;
  }
  
  @Inject
  private PojoResolver pojoResolver;
  
  @Inject
  private DbResolver dbResolver;
  
  @Inject
  private ModelProperty modelProperty;
  
  private final ArrayList<String> STATEMENT_TYPE = CollectionLiterals.<String>newArrayList("QRY", "CRUD", "CALL");
  
  private final ArrayList<String> MAPPING_TYPE = CollectionLiterals.<String>newArrayList("OUT");
  
  private final ArrayList<String> OPTION_TYPE = CollectionLiterals.<String>newArrayList("OPT", "LOPT", "IOPT", "SOPT", "BOPT", "MOPT");
  
  private final ArrayList<String> TYPES = CollectionLiterals.<String>newArrayList("int", "integer", "long", "byte", "short", 
    "float", "double", "character", "char", "string", "str", "time", "date", "datetime", "timestamp", "stamp", 
    "bool", "boolean", "bigint", "biginteger", "bigdec", "bigdecimal", "bytearr", "bytearray", "bytes", "text", 
    "blob", "clob", "einteger", "eint", "enumstring", "estring", "fromdate", "todate", "cursor", "other");
  
  private final ArrayList<String> MODIFIERS = CollectionLiterals.<String>newArrayList("any", "null", "notnull", "seq", "seq=", 
    "idsel", "idsel=", "id", "isDef=", "isCall=", "dtype=", "gtype=", "discr");
  
  private final ArrayList<String> F_TYPES = CollectionLiterals.<String>newArrayList("set", "update", "values", "where");
  
  private final ArrayList<String> DEBUG_LEVELS = CollectionLiterals.<String>newArrayList("DEBUG", "INFO", "FATAL", "ERROR", "WARN", "TRACE");
  
  @Override
  public void completeMetaStatement_Type(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.addProposalList(this.STATEMENT_TYPE, "STATEMENT_TYPE", context, acceptor, null);
  }
  
  @Override
  public void completeMappingRule_Type(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.addProposalList(this.MAPPING_TYPE, "MAPPING_TYPE", context, acceptor, null);
  }
  
  @Override
  public void completeOptionalFeature_Type(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.addProposalList(this.OPTION_TYPE, "OPTION_TYPE", context, acceptor, null);
  }
  
  public void addProposalList(final List<String> values, final String lexerRule, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor, final String prefix) {
    if (values!=null) {
      final Consumer<String> _function = (String value) -> {
        IValueConverterService _valueConverter = this.getValueConverter();
        String _elvis = null;
        if (prefix != null) {
          _elvis = prefix;
        } else {
          _elvis = "";
        }
        String _plus = (_elvis + value);
        final String proposal = _valueConverter.toString(_plus, lexerRule);
        acceptor.accept(this.createCompletionProposal(proposal, context));
      };
      values.forEach(_function);
    }
  }
  
  @Override
  public void completeMetaSql_Ftype(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.addProposalList(this.F_TYPES, "IDENT", context, acceptor, null);
  }
  
  @Override
  public void completeExtendedColumnName_Name(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final Column column = EcoreUtil2.<Column>getContainerOfType(model, Column.class);
    final StringBuilder partialName = new StringBuilder("");
    EList<ExtendedColumn> _columns = null;
    if (column!=null) {
      _columns=column.getColumns();
    }
    if (_columns!=null) {
      final Function1<ExtendedColumn, Boolean> _function = (ExtendedColumn it) -> {
        boolean _xblockexpression = false;
        {
          this.append(partialName, it.getCol().getName());
          _xblockexpression = ((!Objects.equal(context.getPreviousModel(), null)) && (it == context.getPreviousModel()));
        }
        return Boolean.valueOf(_xblockexpression);
      };
      IterableExtensions.<ExtendedColumn>findFirst(_columns, _function);
    }
    final String prefix = this.append(partialName, context.getPrefix()).toString();
    boolean _completeUsage = this.completeUsage(model, assignment, context, acceptor, Constants.COLUMN_USAGE, Constants.COLUMN_USAGE_EXTENDED, prefix, true);
    boolean _not = (!_completeUsage);
    if (_not) {
      super.completeExtendedColumnName_Name(model, assignment, context, acceptor);
    }
  }
  
  @Override
  public void completeConstant_Name(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _completeUsage = this.completeUsage(model, assignment, context, acceptor, Constants.CONSTANT_USAGE, Constants.CONSTANT_USAGE_EXTENDED, context.getPrefix(), false);
    boolean _not = (!_completeUsage);
    if (_not) {
      super.completeConstant_Name(model, assignment, context, acceptor);
    }
  }
  
  @Override
  public void completeIdentifier_Name(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _completeUsage = this.completeUsage(model, assignment, context, acceptor, Constants.IDENTIFIER_USAGE, Constants.IDENTIFIER_USAGE_EXTENDED, context.getPrefix(), 
      false);
    boolean _not = (!_completeUsage);
    if (_not) {
      super.completeIdentifier_Name(model, assignment, context, acceptor);
    }
  }
  
  public boolean completeUsage(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor, final String usageInFilter, final String usageInFilterExt, final String _prefix, final boolean cutPrefix) {
    boolean _isResolvePojo = this.isResolvePojo(model);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return false;
    }
    final MetaStatement metaStatement = EcoreUtil2.<MetaStatement>getContainerOfType(model, MetaStatement.class);
    final Artifacts artifacts = EcoreUtil2.<Artifacts>getContainerOfType(model, Artifacts.class);
    final String pojoName = Utils.getTokenFromModifier(metaStatement, usageInFilter);
    PojoDefinition _xifexpression = null;
    boolean _notEquals = (!Objects.equal(pojoName, null));
    if (_notEquals) {
      _xifexpression = this.modelProperty.getModelPojos(artifacts).get(pojoName);
    }
    final PojoDefinition pojoDefinition = _xifexpression;
    boolean _equals = Objects.equal(pojoDefinition, null);
    if (_equals) {
      final String proposal = this.getValueConverter().toString(("Error: I can\'t load pojo for " + model), "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
      return true;
    }
    final int pos = _prefix.lastIndexOf(".");
    String _xifexpression_1 = null;
    if ((pos > 0)) {
      _xifexpression_1 = _prefix.substring(0, (pos + 1));
    } else {
      _xifexpression_1 = "";
    }
    final String prefix = _xifexpression_1;
    boolean _isOldPojoValidator = this.modelProperty.isOldPojoValidator(model);
    final boolean newPojoValidator = (!_isOldPojoValidator);
    if ((newPojoValidator && (pojoDefinition.getClassx() instanceof JvmDeclaredType))) {
      JvmType _classx = pojoDefinition.getClassx();
      final JvmDeclaredType type = ((JvmDeclaredType) _classx);
      final Consumer<JvmFeature> _function = (JvmFeature feature) -> {
        final String proposal_1 = this.getValueConverter().toString(feature.getSimpleName(), "IDENT");
        InputOutput.<String>println(proposal_1);
        acceptor.accept(this.createCompletionProposal((prefix + proposal_1), context));
      };
      this.getAllFeatures(type, _prefix).forEach(_function);
    } else {
      Resource _eResource = model.eResource();
      URI _uRI = null;
      if (_eResource!=null) {
        _uRI=_eResource.getURI();
      }
      final URI uri = _uRI;
      final String clazz = this.getClassName(pojoDefinition.getQualifiedName(), prefix, uri);
      boolean _equals_1 = Objects.equal(clazz, null);
      if (_equals_1) {
        return false;
      }
      final PropertyDescriptor[] descriptors = this.pojoResolver.getPropertyDescriptors(clazz, uri);
      boolean _equals_2 = Objects.equal(descriptors, null);
      if (_equals_2) {
        return false;
      }
      final Function1<PropertyDescriptor, Boolean> _function_1 = (PropertyDescriptor it) -> {
        String _name = it.getName();
        return Boolean.valueOf((!Objects.equal("class", _name)));
      };
      final Consumer<PropertyDescriptor> _function_2 = (PropertyDescriptor descriptor) -> {
        final String proposal_1 = this.getValueConverter().toString(descriptor.getName(), "IDENT");
        String _xifexpression_2 = null;
        if (cutPrefix) {
          _xifexpression_2 = proposal_1;
        } else {
          _xifexpression_2 = (prefix + proposal_1);
        }
        acceptor.accept(this.createCompletionProposal(_xifexpression_2, context));
      };
      IterableExtensions.<PropertyDescriptor>filter(((Iterable<PropertyDescriptor>)Conversions.doWrapArray(descriptors)), _function_1).forEach(_function_2);
    }
    return true;
  }
  
  public Iterable<JvmFeature> getAllFeatures(final JvmDeclaredType _type, final String _prefix) {
    Iterable<JvmFeature> _xblockexpression = null;
    {
      JvmDeclaredType type = _type;
      final int pos = _prefix.lastIndexOf(".");
      if ((pos > 0)) {
        final Iterable<JvmFeature> features = type.findAllFeaturesByName(_prefix.substring(0, pos));
        if ((((!Objects.equal(features, null)) && (!IterableExtensions.isEmpty(features))) && (IterableExtensions.<JvmFeature>head(features) instanceof JvmField))) {
          JvmFeature _head = IterableExtensions.<JvmFeature>head(features);
          JvmField field = ((JvmField) _head);
          JvmTypeReference _type_1 = field.getType();
          if ((_type_1 instanceof JvmParameterizedTypeReference)) {
            JvmTypeReference _type_2 = field.getType();
            final JvmType jvmType = ((JvmParameterizedTypeReference) _type_2).getType();
            if ((jvmType instanceof JvmDeclaredType)) {
              type = ((JvmDeclaredType) jvmType);
            }
          }
        }
      }
      final Function1<JvmFeature, Boolean> _function = (JvmFeature it) -> {
        return Boolean.valueOf((it instanceof JvmField));
      };
      final Function1<JvmFeature, Boolean> _function_1 = (JvmFeature it) -> {
        boolean _isStatic = it.isStatic();
        return Boolean.valueOf((!_isStatic));
      };
      final Function1<JvmFeature, Boolean> _function_2 = (JvmFeature it) -> {
        boolean _startsWith = it.getSimpleName().startsWith("_");
        return Boolean.valueOf((!_startsWith));
      };
      _xblockexpression = IterableExtensions.<JvmFeature>filter(IterableExtensions.<JvmFeature>filter(IterableExtensions.<JvmFeature>filter(type.getAllFeatures(), _function), _function_1), _function_2);
    }
    return _xblockexpression;
  }
  
  @Override
  public void completeMappingColumnName_Name(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolvePojo = this.isResolvePojo(model);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      super.completeMappingColumnName_Name(model, assignment, context, acceptor);
      return;
    }
    final MappingColumn mappingColumn = EcoreUtil2.<MappingColumn>getContainerOfType(model, MappingColumn.class);
    final MappingRule mappingRule = EcoreUtil2.<MappingRule>getContainerOfType(model, MappingRule.class);
    final Artifacts artifacts = EcoreUtil2.<Artifacts>getContainerOfType(model, Artifacts.class);
    final String pojoName = Utils.getTokenFromModifier(mappingRule, Constants.MAPPING_USAGE);
    PojoDefinition _xifexpression = null;
    boolean _notEquals = (!Objects.equal(pojoName, null));
    if (_notEquals) {
      _xifexpression = this.modelProperty.getModelPojos(artifacts).get(pojoName);
    }
    final PojoDefinition pojoDefinition = _xifexpression;
    boolean _equals = Objects.equal(pojoDefinition, null);
    if (_equals) {
      final String proposal = this.getValueConverter().toString(("Error: I can\'t load pojo for " + model), "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    }
    final StringBuilder partialName = new StringBuilder("");
    boolean cutPrefix = false;
    if (((model instanceof MappingColumn) && (!Objects.equal(mappingColumn, null)))) {
      cutPrefix = true;
      final Function1<ExtendedMappingItem, Boolean> _function = (ExtendedMappingItem it) -> {
        boolean _xblockexpression = false;
        {
          this.append(partialName, it.getAttr().getName());
          _xblockexpression = ((!Objects.equal(context.getPreviousModel(), null)) && (it == context.getPreviousModel()));
        }
        return Boolean.valueOf(_xblockexpression);
      };
      IterableExtensions.<ExtendedMappingItem>findFirst(mappingColumn.getItems(), _function);
    }
    String prefix = this.append(partialName, context.getPrefix()).toString();
    final int pos = prefix.lastIndexOf(".");
    String _xifexpression_1 = null;
    if ((pos > 0)) {
      _xifexpression_1 = prefix.substring(0, (pos + 1));
    } else {
      _xifexpression_1 = "";
    }
    final String _prefix = _xifexpression_1;
    final boolean _cutPrefix = cutPrefix;
    boolean _isOldPojoValidator = this.modelProperty.isOldPojoValidator(model);
    final boolean newPojoValidator = (!_isOldPojoValidator);
    if ((newPojoValidator && (pojoDefinition.getClassx() instanceof JvmDeclaredType))) {
      JvmType _classx = pojoDefinition.getClassx();
      final JvmDeclaredType type = ((JvmDeclaredType) _classx);
      final Consumer<JvmFeature> _function_1 = (JvmFeature feature) -> {
        final String proposal_1 = this.getValueConverter().toString(feature.getSimpleName(), "IDENT");
        InputOutput.<String>println(proposal_1);
        acceptor.accept(this.createCompletionProposal((_prefix + proposal_1), context));
      };
      this.getAllFeatures(type, _prefix).forEach(_function_1);
    } else {
      Resource _eResource = model.eResource();
      URI _uRI = null;
      if (_eResource!=null) {
        _uRI=_eResource.getURI();
      }
      final URI uri = _uRI;
      final String clazz = this.getClassName(pojoDefinition.getQualifiedName(), prefix, uri);
      boolean _equals_1 = Objects.equal(clazz, null);
      if (_equals_1) {
        return;
      }
      final PropertyDescriptor[] descriptors = this.pojoResolver.getPropertyDescriptors(clazz, uri);
      boolean _equals_2 = Objects.equal(descriptors, null);
      if (_equals_2) {
        super.completeMappingColumnName_Name(model, assignment, context, acceptor);
      } else {
        final Function1<PropertyDescriptor, Boolean> _function_2 = (PropertyDescriptor it) -> {
          String _name = it.getName();
          return Boolean.valueOf((!Objects.equal("class", _name)));
        };
        final Consumer<PropertyDescriptor> _function_3 = (PropertyDescriptor descriptor) -> {
          final String proposal_1 = this.getValueConverter().toString(descriptor.getName(), "IDENT");
          String _xifexpression_2 = null;
          if (_cutPrefix) {
            _xifexpression_2 = proposal_1;
          } else {
            _xifexpression_2 = (_prefix + proposal_1);
          }
          acceptor.accept(this.createCompletionProposal(_xifexpression_2, context));
        };
        IterableExtensions.<PropertyDescriptor>filter(((Iterable<PropertyDescriptor>)Conversions.doWrapArray(descriptors)), _function_2).forEach(_function_3);
      }
    }
  }
  
  public StringBuilder append(final StringBuilder sb, final String s) {
    StringBuilder _xblockexpression = null;
    {
      int _length = sb.length();
      boolean _greaterThan = (_length > 0);
      if (_greaterThan) {
        sb.append(".");
      }
      _xblockexpression = sb.append(s);
    }
    return _xblockexpression;
  }
  
  public boolean isResolvePojo(final EObject model) {
    return this.modelProperty.isDoResolvePojo(model);
  }
  
  public boolean isResolveDb(final EObject model) {
    return this.dbResolver.isResolveDb(model);
  }
  
  public boolean isPrimitive(final Class<?> clazz) {
    boolean _equals = Objects.equal(clazz, null);
    if (_equals) {
      return true;
    }
    boolean _equals_1 = Objects.equal(clazz, String.class);
    if (_equals_1) {
      return true;
    }
    boolean _equals_2 = Objects.equal(clazz, Date.class);
    if (_equals_2) {
      return true;
    }
    boolean _equals_3 = Objects.equal(clazz, java.sql.Date.class);
    if (_equals_3) {
      return true;
    }
    boolean _equals_4 = Objects.equal(clazz, Time.class);
    if (_equals_4) {
      return true;
    }
    boolean _equals_5 = Objects.equal(clazz, Timestamp.class);
    if (_equals_5) {
      return true;
    }
    boolean _equals_6 = Objects.equal(clazz, Blob.class);
    if (_equals_6) {
      return true;
    }
    boolean _equals_7 = Objects.equal(clazz, Clob.class);
    if (_equals_7) {
      return true;
    }
    boolean _equals_8 = Objects.equal(clazz, BigDecimal.class);
    if (_equals_8) {
      return true;
    }
    boolean _equals_9 = Objects.equal(clazz, BigInteger.class);
    if (_equals_9) {
      return true;
    }
    return false;
  }
  
  public String getClassName(final String baseClass, final String property, final URI uri) {
    if ((Objects.equal(baseClass, null) || Objects.equal(property, null))) {
      return baseClass;
    }
    int pos1 = property.indexOf(".");
    if ((pos1 == (-1))) {
      return baseClass;
    }
    String checkProperty = property;
    pos1 = checkProperty.indexOf("=");
    if ((pos1 > 0)) {
      int pos2 = checkProperty.indexOf(".", pos1);
      if ((pos2 > pos1)) {
        String _substring = checkProperty.substring(0, pos1);
        String _substring_1 = checkProperty.substring(pos2);
        String _plus = (_substring + _substring_1);
        checkProperty = _plus;
      }
    }
    String innerProperty = ((String) null);
    pos1 = checkProperty.indexOf(".");
    if ((pos1 > 0)) {
      innerProperty = checkProperty.substring((pos1 + 1));
      checkProperty = checkProperty.substring(0, pos1);
    }
    PropertyDescriptor[] descriptors = this.pojoResolver.getPropertyDescriptors(baseClass, uri);
    boolean _equals = Objects.equal(descriptors, null);
    if (_equals) {
      return null;
    }
    final String _checkProperty = checkProperty;
    final PropertyDescriptor[] _converted_descriptors = (PropertyDescriptor[])descriptors;
    final Function1<PropertyDescriptor, Boolean> _function = (PropertyDescriptor descriptor) -> {
      String _name = descriptor.getName();
      return Boolean.valueOf(Objects.equal(_name, _checkProperty));
    };
    PropertyDescriptor innerDesriptor = IterableExtensions.<PropertyDescriptor>findFirst(((Iterable<PropertyDescriptor>)Conversions.doWrapArray(_converted_descriptors)), _function);
    boolean _equals_1 = Objects.equal(innerDesriptor, null);
    if (_equals_1) {
      return null;
    }
    Class<?> innerClass = innerDesriptor.getPropertyType();
    boolean _isArray = innerClass.isArray();
    if (_isArray) {
      Type _genericReturnType = innerDesriptor.getReadMethod().getGenericReturnType();
      ParameterizedType type = ((ParameterizedType) _genericReturnType);
      if ((Objects.equal(type.getActualTypeArguments(), null) || (type.getActualTypeArguments().length == 0))) {
        return null;
      }
      Type _head = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(type.getActualTypeArguments())));
      innerClass = ((Class<?>) _head);
      boolean _isPrimitive = this.isPrimitive(innerClass);
      if (_isPrimitive) {
        return null;
      }
      return this.getClassName(innerClass.getName(), innerProperty, uri);
    } else {
      boolean _isAssignableFrom = Collection.class.isAssignableFrom(innerClass);
      if (_isAssignableFrom) {
        Type _genericReturnType_1 = innerDesriptor.getReadMethod().getGenericReturnType();
        ParameterizedType type_1 = ((ParameterizedType) _genericReturnType_1);
        if ((Objects.equal(type_1.getActualTypeArguments(), null) || (type_1.getActualTypeArguments().length == 0))) {
          return null;
        }
        Type _head_1 = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(type_1.getActualTypeArguments())));
        innerClass = ((Class<?>) _head_1);
        boolean _isPrimitive_1 = this.isPrimitive(innerClass);
        if (_isPrimitive_1) {
          return null;
        }
        return this.getClassName(innerClass.getName(), innerProperty, uri);
      } else {
        boolean _isPrimitive_2 = this.isPrimitive(innerClass);
        if (_isPrimitive_2) {
          return null;
        }
        return this.getClassName(innerClass.getName(), innerProperty, uri);
      }
    }
  }
  
  public void acceptTables(final EObject model, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor, final String suffix) {
    final Function1<String, Boolean> _function = (String it) -> {
      int _indexOf = it.indexOf("$");
      return Boolean.valueOf((_indexOf < 0));
    };
    final Consumer<String> _function_1 = (String table) -> {
      final String proposal = this.getValueConverter().toString(table, "IDENT");
      acceptor.accept(this.createCompletionProposal((proposal + suffix), context));
    };
    IterableExtensions.<String>filter(this.dbResolver.getTables(model), _function).forEach(_function_1);
  }
  
  public void acceptProcedures(final EObject model, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final Function1<String, Boolean> _function = (String it) -> {
      int _indexOf = it.indexOf("$");
      return Boolean.valueOf((_indexOf < 0));
    };
    final Consumer<String> _function_1 = (String table) -> {
      final String proposal = this.getValueConverter().toString(table, "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    IterableExtensions.<String>filter(this.dbResolver.getProcedures(model), _function).forEach(_function_1);
  }
  
  public void acceptFunctions(final EObject model, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final Function1<String, Boolean> _function = (String it) -> {
      int _indexOf = it.indexOf("$");
      return Boolean.valueOf((_indexOf < 0));
    };
    final Consumer<String> _function_1 = (String table) -> {
      final String proposal = this.getValueConverter().toString(table, "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    IterableExtensions.<String>filter(this.dbResolver.getFunctions(model), _function).forEach(_function_1);
  }
  
  public void acceptCheckConstraints(final EObject model, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final Function1<String, Boolean> _function = (String it) -> {
      int _indexOf = it.indexOf("$");
      return Boolean.valueOf((_indexOf < 0));
    };
    final Consumer<String> _function_1 = (String table) -> {
      final String proposal = this.getValueConverter().toString(table, "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    IterableExtensions.<String>filter(this.dbResolver.getCheckConstraints(model), _function).forEach(_function_1);
  }
  
  public void acceptSequences(final EObject model, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final Function1<String, Boolean> _function = (String it) -> {
      int _indexOf = it.indexOf("$");
      return Boolean.valueOf((_indexOf < 0));
    };
    final Consumer<String> _function_1 = (String table) -> {
      final String proposal = this.getValueConverter().toString(table, "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    IterableExtensions.<String>filter(this.dbResolver.getSequences(model), _function).forEach(_function_1);
  }
  
  public void acceptColumns(final List<String> columns, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor, final String prefix, final String suffix) {
    final Consumer<String> _function = (String column) -> {
      final String proposal = this.getValueConverter().toString(column, "IDENT");
      String _xifexpression = null;
      boolean _notEquals = (!Objects.equal(prefix, null));
      if (_notEquals) {
        _xifexpression = ((prefix + ".") + proposal);
      } else {
        _xifexpression = proposal;
      }
      String completion = _xifexpression;
      String _xifexpression_1 = null;
      boolean _notEquals_1 = (!Objects.equal(suffix, null));
      if (_notEquals_1) {
        _xifexpression_1 = (completion + suffix);
      } else {
        _xifexpression_1 = completion;
      }
      completion = _xifexpression_1;
      acceptor.accept(this.createCompletionProposal(completion, context));
    };
    columns.forEach(_function);
  }
  
  @Override
  public void completeTableDefinitionModel_Table(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeTableDefinitionModel_Table(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  @Override
  public void completeProcedureDefinitionModel_Table(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeProcedureDefinitionModel_Table(model, assignment, context, acceptor);
      return;
    }
    this.acceptProcedures(model, context, acceptor);
  }
  
  @Override
  public void completeFunctionDefinitionModel_Table(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeFunctionDefinitionModel_Table(model, assignment, context, acceptor);
      return;
    }
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void complete_DatabaseColumn(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.complete_DatabaseColumn(model, ruleCall, context, acceptor);
      return;
    }
    final int pos = context.getPrefix().indexOf(".");
    String _xifexpression = null;
    if ((pos > 0)) {
      _xifexpression = context.getPrefix().substring(0, pos);
    }
    final String prefix = _xifexpression;
    final MetaStatement metaStatement = EcoreUtil2.<MetaStatement>getContainerOfType(model, MetaStatement.class);
    final Artifacts artifacts = EcoreUtil2.<Artifacts>getContainerOfType(model, Artifacts.class);
    final String value = Utils.getTokenFromModifier(metaStatement, Constants.TABLE_USAGE, prefix);
    TableDefinition _xifexpression_1 = null;
    boolean _notEquals = (!Objects.equal(value, null));
    if (_notEquals) {
      _xifexpression_1 = this.modelProperty.getModelTables(artifacts).get(value);
    }
    final TableDefinition tableDefinition = _xifexpression_1;
    if (((!Objects.equal(tableDefinition, null)) && (!Objects.equal(tableDefinition.getTable(), null)))) {
      this.acceptColumns(this.dbResolver.getColumns(model, tableDefinition.getTable()), context, acceptor, prefix, null);
    }
  }
  
  @Override
  public void complete_DatabaseTable(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.complete_DatabaseTable(model, ruleCall, context, acceptor);
      return;
    }
    final MetaStatement metaStatement = EcoreUtil2.<MetaStatement>getContainerOfType(model, MetaStatement.class);
    final Artifacts artifacts = EcoreUtil2.<Artifacts>getContainerOfType(model, Artifacts.class);
    final Consumer<String> _function = (String value) -> {
      final TableDefinition tableDefinition = this.modelProperty.getModelTables(artifacts).get(value);
      boolean _notEquals = (!Objects.equal(tableDefinition, null));
      if (_notEquals) {
        final String proposal = this.getValueConverter().toString(tableDefinition.getTable(), "IDENT");
        acceptor.accept(this.createCompletionProposal(proposal, context));
      }
    };
    Utils.getTokensFromModifier(metaStatement, Constants.TABLE_USAGE).forEach(_function);
  }
  
  @Override
  public void completePojogenProperty_DbTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completePojogenProperty_DbTable(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptCheckConstraints(model, context, acceptor);
  }
  
  @Override
  public void completePojogenProperty_DbProcedure(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completePojogenProperty_DbProcedure(model, assignment, context, acceptor);
      return;
    }
    this.acceptProcedures(model, context, acceptor);
  }
  
  @Override
  public void completePojogenProperty_DbFunction(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completePojogenProperty_DbFunction(model, assignment, context, acceptor);
      return;
    }
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeTableAssignement_DbTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeTableAssignement_DbTable(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "->");
  }
  
  @Override
  public void completeInheritanceAssignement_DbTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeInheritanceAssignement_DbTable(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "->");
  }
  
  @Override
  public void completePojogenProperty_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completePojogenProperty_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  @Override
  public void completePojogenProperty_DbNotTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completePojogenProperty_DbNotTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  @Override
  public void completeMetagenProperty_DbNotTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeMetagenProperty_DbNotTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  @Override
  public void completePojogenProperty_DbColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completePojogenProperty_DbColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, null);
    }
  }
  
  @Override
  public void completePojogenProperty_DbColumns(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completePojogenProperty_DbColumns(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, null);
    }
  }
  
  @Override
  public void completeImplementsAssignement_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeImplementsAssignement_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeExtendsAssignement_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeExtendsAssignement_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeImplementsAssignement_DbNotTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeImplementsAssignement_DbNotTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeExtendsAssignement_DbNotTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeExtendsAssignement_DbNotTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeImplementsAssignementGenerics_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeImplementsAssignementGenerics_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeExtendsAssignementGenerics_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeExtendsAssignementGenerics_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeImplementsAssignementGenerics_DbNotTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeImplementsAssignementGenerics_DbNotTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeExtendsAssignementGenerics_DbNotTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeExtendsAssignementGenerics_DbNotTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
    this.acceptProcedures(model, context, acceptor);
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeColumnTypeAssignement_DbColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completeColumnTypeAssignement_DbColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, "->");
    } else {
      String _dbProcedure = prop.getDbProcedure();
      boolean _notEquals_1 = (!Objects.equal(_dbProcedure, null));
      if (_notEquals_1) {
        this.acceptColumns(this.dbResolver.getProcColumns(model, prop.getDbProcedure()), context, acceptor, null, "->");
      } else {
        String _dbFunction = prop.getDbFunction();
        boolean _notEquals_2 = (!Objects.equal(_dbFunction, null));
        if (_notEquals_2) {
          this.acceptColumns(this.dbResolver.getFunColumns(model, prop.getDbFunction()), context, acceptor, null, "->");
        }
      }
    }
  }
  
  @Override
  public void completeColumnAssignement_DbColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completeColumnAssignement_DbColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, "->");
      this.acceptColumns(this.dbResolver.getCheckColumns(model, prop.getDbTable()), context, acceptor, null, "->");
    }
  }
  
  @Override
  public void completeImportAssignement_PkTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof ImportAssignement)))) {
      super.completeImportAssignement_PkTable(model, assignment, context, acceptor);
      return;
    }
    final ImportAssignement imp = ((ImportAssignement) model);
    final PojogenProperty prop = EcoreUtil2.<PojogenProperty>getContainerOfType(model, PojogenProperty.class);
    if (((!Objects.equal(prop.getDbTable(), null)) && (!Objects.equal(imp.getDbColumn(), null)))) {
      String _name = prop.getName();
      boolean _equals = Objects.equal("create-many-to-one", _name);
      if (_equals) {
        this.acceptTables(model, context, acceptor, "");
      } else {
        final Consumer<DbImport> _function = (DbImport dbImport) -> {
          if (((!Objects.equal(dbImport.getFkColumn(), null)) && dbImport.getFkColumn().equals(imp.getDbColumn()))) {
            final String proposal = this.getValueConverter().toString(dbImport.getPkTable(), "IDENT");
            acceptor.accept(this.createCompletionProposal(proposal, context));
          }
        };
        this.dbResolver.getDbImports(model, prop.getDbTable()).forEach(_function);
      }
    }
  }
  
  @Override
  public void completeImportAssignement_PkColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof ImportAssignement)))) {
      super.completeImportAssignement_PkColumn(model, assignment, context, acceptor);
      return;
    }
    final ImportAssignement imp = ((ImportAssignement) model);
    final PojogenProperty prop = EcoreUtil2.<PojogenProperty>getContainerOfType(model, PojogenProperty.class);
    if ((((!Objects.equal(prop.getDbTable(), null)) && (!Objects.equal(imp.getDbColumn(), null))) && (!Objects.equal(imp.getPkTable(), null)))) {
      String _name = prop.getName();
      boolean _equals = Objects.equal("create-many-to-one", _name);
      if (_equals) {
        this.acceptColumns(this.dbResolver.getColumns(model, imp.getPkTable()), context, acceptor, null, null);
      } else {
        final Consumer<DbImport> _function = (DbImport dbImport) -> {
          if (((!Objects.equal(dbImport.getFkColumn(), null)) && dbImport.getFkColumn().equals(imp.getDbColumn()))) {
            if (((!Objects.equal(dbImport.getPkTable(), null)) && dbImport.getPkTable().equals(imp.getPkTable()))) {
              final String proposal = this.getValueConverter().toString(dbImport.getPkColumn(), "IDENT");
              acceptor.accept(this.createCompletionProposal(proposal, context));
            }
          }
        };
        this.dbResolver.getDbImports(model, prop.getDbTable()).forEach(_function);
      }
    }
  }
  
  @Override
  public void completeImportAssignement_DbColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completeImportAssignement_DbColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, "->");
    }
  }
  
  @Override
  public void completeExportAssignement_FkTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof ExportAssignement)))) {
      super.completeExportAssignement_FkTable(model, assignment, context, acceptor);
      return;
    }
    final ExportAssignement exp = ((ExportAssignement) model);
    final PojogenProperty prop = EcoreUtil2.<PojogenProperty>getContainerOfType(model, PojogenProperty.class);
    if (((!Objects.equal(prop.getDbTable(), null)) && (!Objects.equal(exp.getDbColumn(), null)))) {
      String _name = prop.getName();
      boolean _equals = Objects.equal("create-one-to-many", _name);
      if (_equals) {
        this.acceptTables(model, context, acceptor, "");
      } else {
        final Consumer<DbExport> _function = (DbExport dbExport) -> {
          if (((!Objects.equal(dbExport.getPkColumn(), null)) && dbExport.getPkColumn().equals(exp.getDbColumn()))) {
            final String proposal = this.getValueConverter().toString(dbExport.getFkTable(), "IDENT");
            acceptor.accept(this.createCompletionProposal(proposal, context));
          }
        };
        this.dbResolver.getDbExports(model, prop.getDbTable()).forEach(_function);
      }
    }
  }
  
  @Override
  public void completeExportAssignement_FkColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof ExportAssignement)))) {
      super.completeExportAssignement_FkColumn(model, assignment, context, acceptor);
      return;
    }
    final ExportAssignement exp = ((ExportAssignement) model);
    final PojogenProperty prop = EcoreUtil2.<PojogenProperty>getContainerOfType(model, PojogenProperty.class);
    if ((((!Objects.equal(prop.getDbTable(), null)) && (!Objects.equal(exp.getDbColumn(), null))) && (!Objects.equal(exp.getFkTable(), null)))) {
      String _name = prop.getName();
      boolean _equals = Objects.equal("create-one-to-many", _name);
      if (_equals) {
        this.acceptColumns(this.dbResolver.getColumns(model, exp.getFkTable()), context, acceptor, null, null);
      } else {
        final Consumer<DbExport> _function = (DbExport dbExport) -> {
          if (((!Objects.equal(dbExport.getPkColumn(), null)) && dbExport.getPkColumn().equals(exp.getDbColumn()))) {
            if (((!Objects.equal(dbExport.getFkTable(), null)) && dbExport.getFkTable().equals(exp.getFkTable()))) {
              final String proposal = this.getValueConverter().toString(dbExport.getFkColumn(), "IDENT");
              acceptor.accept(this.createCompletionProposal(proposal, context));
            }
          }
        };
        this.dbResolver.getDbExports(model, prop.getDbTable()).forEach(_function);
      }
    }
  }
  
  @Override
  public void completeExportAssignement_DbColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completeExportAssignement_DbColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, "->");
    }
  }
  
  @Override
  public void completeManyToManyAssignement_PkColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completeManyToManyAssignement_PkColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, "->");
    }
  }
  
  @Override
  public void completeManyToManyAssignement_PkTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof ManyToManyAssignement)))) {
      super.completeManyToManyAssignement_PkTable(model, assignment, context, acceptor);
      return;
    }
    final ManyToManyAssignement many2 = ((ManyToManyAssignement) model);
    final PojogenProperty prop = EcoreUtil2.<PojogenProperty>getContainerOfType(model, PojogenProperty.class);
    if (((!Objects.equal(prop.getDbTable(), null)) && (!Objects.equal(many2.getPkColumn(), null)))) {
      final Consumer<DbImport> _function = (DbImport dbImport) -> {
        if (((!Objects.equal(dbImport.getPkColumn(), null)) && dbImport.getPkColumn().equals(many2.getPkColumn()))) {
          final String proposal = this.getValueConverter().toString(dbImport.getPkTable(), "IDENT");
          acceptor.accept(this.createCompletionProposal(proposal, context));
        }
      };
      this.dbResolver.getDbImports(model, prop.getDbTable()).forEach(_function);
    }
  }
  
  @Override
  public void completeInheritanceAssignement_DbColumns(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof InheritanceAssignement)))) {
      super.completeInheritanceAssignement_DbColumns(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = EcoreUtil2.<PojogenProperty>getContainerOfType(model, PojogenProperty.class);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, null);
    }
  }
  
  private final ArrayList<String> methods = CollectionLiterals.<String>newArrayList("toString", "hashCode", "equals", "isDef", "toInit", "enumDef", 
    "enumInit", "index", "procId", "enumIndex");
  
  @Override
  public void completePojogenProperty_Methods(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if ((!(model instanceof PojogenProperty))) {
      super.completePojogenProperty_Methods(model, assignment, context, acceptor);
      return;
    }
    final Consumer<String> _function = (String method) -> {
      final String proposal = this.getValueConverter().toString(method, "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    this.methods.forEach(_function);
  }
  
  @Override
  public void completeShowColumnTypeAssignement_DbColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof PojogenProperty)))) {
      super.completeShowColumnTypeAssignement_DbColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    String _dbTable = prop.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, "->");
    } else {
      String _dbProcedure = prop.getDbProcedure();
      boolean _notEquals_1 = (!Objects.equal(_dbProcedure, null));
      if (_notEquals_1) {
        this.acceptColumns(this.dbResolver.getProcColumns(model, prop.getDbProcedure()), context, acceptor, null, "->");
      } else {
        String _dbFunction = prop.getDbFunction();
        boolean _notEquals_2 = (!Objects.equal(_dbFunction, null));
        if (_notEquals_2) {
          this.acceptColumns(this.dbResolver.getFunColumns(model, prop.getDbFunction()), context, acceptor, null, "->");
        }
      }
    }
  }
  
  @Override
  public void completeShowColumnTypeAssignement_Type(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof ShowColumnTypeAssignement)))) {
      super.completeShowColumnTypeAssignement_Type(model, assignment, context, acceptor);
      return;
    }
    final ShowColumnTypeAssignement prop = ((ShowColumnTypeAssignement) model);
    final PojogenProperty prop2 = EcoreUtil2.<PojogenProperty>getContainerOfType(model, PojogenProperty.class);
    String type = ((String) null);
    String _dbTable = prop2.getDbTable();
    boolean _notEquals = (!Objects.equal(_dbTable, null));
    if (_notEquals) {
      type = this.dbResolver.getType(model, prop2.getDbTable(), prop.getDbColumn());
    } else {
      String _dbProcedure = prop2.getDbProcedure();
      boolean _notEquals_1 = (!Objects.equal(_dbProcedure, null));
      if (_notEquals_1) {
        type = this.dbResolver.getType(model, prop2.getDbProcedure(), prop.getDbColumn());
      } else {
        String _dbFunction = prop2.getDbFunction();
        boolean _notEquals_2 = (!Objects.equal(_dbFunction, null));
        if (_notEquals_2) {
          type = this.dbResolver.getType(model, prop2.getDbFunction(), prop.getDbColumn());
        }
      }
    }
    boolean _notEquals_3 = (!Objects.equal(type, null));
    if (_notEquals_3) {
      final String proposal = this.getValueConverter().toString(type, "PropertyValue");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    }
  }
  
  @Override
  public void completeJoinTableAssignement_DbTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeJoinTableAssignement_DbTable(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "->");
  }
  
  @Override
  public void completeJoinTableAssignement_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeJoinTableAssignement_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  public Set<PojoDefinitionModel> listPojos(final ResourceSet resourceSet, final IScope scope) {
    final Comparator<PojoDefinitionModel> _function = (PojoDefinitionModel o1, PojoDefinitionModel o2) -> {
      return o1.getName().compareTo(o2.getName());
    };
    final TreeSet<PojoDefinitionModel> result = CollectionLiterals.<PojoDefinitionModel>newTreeSet(_function);
    final Consumer<IEObjectDescription> _function_1 = (IEObjectDescription description) -> {
      EObject _eObject = resourceSet.getEObject(description.getEObjectURI(), true);
      final PojoDefinitionModel pojo = ((PojoDefinitionModel) _eObject);
      result.add(pojo);
    };
    scope.getAllElements().forEach(_function_1);
    return result;
  }
  
  public Set<TableDefinitionModel> listTables(final ResourceSet resourceSet, final IScope scope) {
    final Comparator<TableDefinitionModel> _function = (TableDefinitionModel o1, TableDefinitionModel o2) -> {
      return o1.getName().compareTo(o2.getName());
    };
    final TreeSet<TableDefinitionModel> result = CollectionLiterals.<TableDefinitionModel>newTreeSet(_function);
    final Consumer<IEObjectDescription> _function_1 = (IEObjectDescription description) -> {
      EObject _eObject = resourceSet.getEObject(description.getEObjectURI(), true);
      final TableDefinitionModel table = ((TableDefinitionModel) _eObject);
      result.add(table);
    };
    scope.getAllElements().forEach(_function_1);
    return result;
  }
  
  @Override
  public void complete_StatementModifier(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final MetaStatement metaStatement = EcoreUtil2.<MetaStatement>getContainerOfType(model, MetaStatement.class);
    final Artifacts artifacts = EcoreUtil2.<Artifacts>getContainerOfType(metaStatement, Artifacts.class);
    final Set<PojoDefinitionModel> pojos = this.listPojos(artifacts.eResource().getResourceSet(), 
      this.getScopeProvider().getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS));
    final Consumer<PojoDefinitionModel> _function = (PojoDefinitionModel pojo) -> {
      final String proposal = this.getValueConverter().toString(pojo.getName(), "IDENT");
      acceptor.accept(this.createCompletionProposal(((Constants.CONSTANT_USAGE + "=") + proposal), context));
      acceptor.accept(this.createCompletionProposal(((Constants.IDENTIFIER_USAGE + "=") + proposal), context));
      acceptor.accept(this.createCompletionProposal(((Constants.COLUMN_USAGE + "=") + proposal), context));
      acceptor.accept(this.createCompletionProposal(((Constants.INDEX_USAGE + "=") + proposal), context));
    };
    pojos.forEach(_function);
    final Set<TableDefinitionModel> tables = this.listTables(artifacts.eResource().getResourceSet(), 
      this.getScopeProvider().getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__TABLES));
    final Consumer<TableDefinitionModel> _function_1 = (TableDefinitionModel table) -> {
      final String proposal = this.getValueConverter().toString(table.getName(), "IDENT");
      acceptor.accept(this.createCompletionProposal(((Constants.TABLE_USAGE + "=") + proposal), context));
    };
    tables.forEach(_function_1);
  }
  
  @Override
  public void complete_MappingRuleModifier(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final MappingRule mappingRule = EcoreUtil2.<MappingRule>getContainerOfType(model, MappingRule.class);
    final Artifacts artifacts = EcoreUtil2.<Artifacts>getContainerOfType(mappingRule, Artifacts.class);
    final Set<PojoDefinitionModel> pojos = this.listPojos(artifacts.eResource().getResourceSet(), 
      this.getScopeProvider().getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS));
    final Consumer<PojoDefinitionModel> _function = (PojoDefinitionModel pojo) -> {
      final String proposal = this.getValueConverter().toString(pojo.getName(), "IDENT");
      acceptor.accept(this.createCompletionProposal(((Constants.MAPPING_USAGE + "=") + proposal), context));
    };
    pojos.forEach(_function);
  }
  
  @Override
  public void complete_Modifier(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.addProposalList(this.TYPES, "IDENT", context, acceptor, "type=");
    this.addProposalList(this.MODIFIERS, "IDENT", context, acceptor, null);
  }
  
  @Override
  public void complete_MappingItemModifier(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.addProposalList(this.TYPES, "IDENT", context, acceptor, "type=");
    this.addProposalList(this.MODIFIERS, "IDENT", context, acceptor, null);
  }
  
  @Override
  public void completeMetagenProperty_DbTable(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeMetagenProperty_DbTable(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  @Override
  public void completeMetagenProperty_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeMetagenProperty_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  @Override
  public void completeMetagenProperty_DbFunction(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeMetagenProperty_DbFunction(model, assignment, context, acceptor);
      return;
    }
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeMetagenProperty_DbProcedure(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeMetagenProperty_DbProcedure(model, assignment, context, acceptor);
      return;
    }
    this.acceptProcedures(model, context, acceptor);
  }
  
  @Override
  public void completeMetagenProperty_Sequence(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeMetagenProperty_Sequence(model, assignment, context, acceptor);
      return;
    }
    this.acceptSequences(model, context, acceptor);
  }
  
  @Override
  public void completeMetaTypeAssignement_DbColumn(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof MetagenProperty)))) {
      super.completeMetaTypeAssignement_DbColumn(model, assignment, context, acceptor);
      return;
    }
    final PojogenProperty prop = ((PojogenProperty) model);
    this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, null);
  }
  
  @Override
  public void completeDaogenProperty_DbTables(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeDaogenProperty_DbTables(model, assignment, context, acceptor);
      return;
    }
    this.acceptTables(model, context, acceptor, "");
  }
  
  @Override
  public void completeMetagenProperty_DbColumns(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof MetagenProperty)))) {
      super.completeMetagenProperty_DbColumns(model, assignment, context, acceptor);
      return;
    }
    final MetagenProperty prop = ((MetagenProperty) model);
    this.acceptColumns(this.dbResolver.getColumns(model, prop.getDbTable()), context, acceptor, null, null);
  }
  
  @Override
  public void completeDatabaseMetaInfoAssignement_DbMetaInfo(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeDatabaseMetaInfoAssignement_DbMetaInfo(model, assignment, context, acceptor);
      return;
    }
    String dbMetaInfo = this.dbResolver.getDbMetaInfo(model);
    boolean _notEquals = (!Objects.equal(dbMetaInfo, null));
    if (_notEquals) {
      dbMetaInfo = (("\"" + dbMetaInfo) + "\"");
    }
    final String proposal = this.getValueConverter().toString(dbMetaInfo, "PropertyValue");
    acceptor.accept(this.createCompletionProposal(proposal, context));
  }
  
  @Override
  public void completeDriverMetaInfoAssignement_DbDriverInfo(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeDriverMetaInfoAssignement_DbDriverInfo(model, assignment, context, acceptor);
      return;
    }
    String dbDriverInfo = this.dbResolver.getDbDriverInfo(model);
    boolean _notEquals = (!Objects.equal(dbDriverInfo, null));
    if (_notEquals) {
      dbDriverInfo = (("\"" + dbDriverInfo) + "\"");
    }
    final String proposal = this.getValueConverter().toString(dbDriverInfo, "PropertyValue");
    acceptor.accept(this.createCompletionProposal(proposal, context));
  }
  
  @Override
  public void completeDriverMethodOutputAssignement_DriverMethod(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof DatabaseProperty)))) {
      super.completeDriverMethodOutputAssignement_DriverMethod(model, assignment, context, acceptor);
      return;
    }
    final Consumer<String> _function = (String driverMetod) -> {
      final String proposal = this.getValueConverter().toString(driverMetod, "PropertyValue");
      acceptor.accept(this.createCompletionProposal((proposal + "->"), context));
    };
    this.dbResolver.getDriverMethods(model).forEach(_function);
  }
  
  @Override
  public void completeDriverMethodOutputAssignement_CallOutput(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    if (((!this.isResolveDb(model)) || (!(model instanceof DriverMethodOutputAssignement)))) {
      super.completeDriverMethodOutputAssignement_CallOutput(model, assignment, context, acceptor);
      return;
    }
    final DriverMethodOutputAssignement prop = ((DriverMethodOutputAssignement) model);
    Object _elvis = null;
    Object _driverMethodOutput = this.dbResolver.getDriverMethodOutput(model, prop.getDriverMethod());
    if (_driverMethodOutput != null) {
      _elvis = _driverMethodOutput;
    } else {
      _elvis = "null";
    }
    Object methodCallOutput = _elvis;
    final String proposal = this.getValueConverter().toString((("\"" + methodCallOutput) + "\""), "PropertyValue");
    acceptor.accept(this.createCompletionProposal(proposal, context));
  }
  
  @Override
  public void completeDatabaseTypeAssignement_DbType(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeDatabaseTypeAssignement_DbType(model, assignment, context, acceptor);
      return;
    }
    final String dbMetaInfo = this.dbResolver.getDbMetaInfo(model);
    final Consumer<DbResolver.DbType> _function = (DbResolver.DbType dbType) -> {
      final String proposal = this.getValueConverter().toString(dbType.getValue(), "PropertyValue");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    ((List<DbResolver.DbType>)Conversions.doWrapArray(DbResolver.DbType.fromDbMetaInfo(dbMetaInfo))).forEach(_function);
  }
  
  @Override
  public void completeDatabaseCatalogAssignement_DbCatalog(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeDatabaseCatalogAssignement_DbCatalog(model, assignment, context, acceptor);
      return;
    }
    final Consumer<String> _function = (String catalog) -> {
      final String proposal = this.getValueConverter().toString(catalog, "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    this.dbResolver.getCatalogs(model).forEach(_function);
  }
  
  @Override
  public void completeDatabaseSchemaAssignement_DbSchema(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeDatabaseSchemaAssignement_DbSchema(model, assignment, context, acceptor);
      return;
    }
    final Consumer<String> _function = (String schema) -> {
      final String proposal = this.getValueConverter().toString(schema, "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
    };
    this.dbResolver.getSchemas(model).forEach(_function);
  }
  
  @Override
  public void completeDebugLevelAssignement_Debug(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.addProposalList(this.DEBUG_LEVELS, "DEBUG_LEVELS", context, acceptor, null);
  }
  
  @Override
  public void completeProcedurePojoAssignement_DbProcedure(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeProcedurePojoAssignement_DbProcedure(model, assignment, context, acceptor);
      return;
    }
    this.acceptProcedures(model, context, acceptor);
  }
  
  @Override
  public void completeFunctionPojoAssignement_DbFunction(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolveDb = this.isResolveDb(model);
    boolean _not = (!_isResolveDb);
    if (_not) {
      super.completeFunctionPojoAssignement_DbFunction(model, assignment, context, acceptor);
      return;
    }
    this.acceptFunctions(model, context, acceptor);
  }
  
  @Override
  public void completeOrdSql_Ident(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isResolvePojo = this.isResolvePojo(model);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      super.completeOrdSql_Ident(model, assignment, context, acceptor);
      return;
    }
    final MetaStatement metaStatement = EcoreUtil2.<MetaStatement>getContainerOfType(model, MetaStatement.class);
    final Artifacts artifacts = EcoreUtil2.<Artifacts>getContainerOfType(model, Artifacts.class);
    String pojoName = Utils.getTokenFromModifier(metaStatement, Constants.INDEX_USAGE);
    boolean _equals = Objects.equal(pojoName, null);
    if (_equals) {
      pojoName = Utils.getTokenFromModifier(metaStatement, Constants.IDENTIFIER_USAGE);
    }
    PojoDefinition _xifexpression = null;
    boolean _notEquals = (!Objects.equal(pojoName, null));
    if (_notEquals) {
      _xifexpression = this.modelProperty.getModelPojos(artifacts).get(pojoName);
    }
    final PojoDefinition pojoDefinition = _xifexpression;
    boolean _equals_1 = Objects.equal(pojoDefinition, null);
    if (_equals_1) {
      final String proposal = this.getValueConverter().toString(("Error: I can\'t load pojo for " + model), "IDENT");
      acceptor.accept(this.createCompletionProposal(proposal, context));
      return;
    }
    boolean _isOldPojoValidator = this.modelProperty.isOldPojoValidator(model);
    final boolean newPojoValidator = (!_isOldPojoValidator);
    if ((newPojoValidator && (pojoDefinition.getClassx() instanceof JvmDeclaredType))) {
      final ProcessorMetaProposalProvider.Founder founder = new ProcessorMetaProposalProvider.Founder();
      JvmType _classx = pojoDefinition.getClassx();
      final JvmDeclaredType type = ((JvmDeclaredType) _classx);
      final Function1<JvmFeature, Boolean> _function = (JvmFeature it) -> {
        return Boolean.valueOf((it instanceof JvmField));
      };
      final Function1<JvmFeature, Boolean> _function_1 = (JvmFeature it) -> {
        return Boolean.valueOf(it.isStatic());
      };
      final Function1<JvmFeature, Boolean> _function_2 = (JvmFeature it) -> {
        return Boolean.valueOf(it.getSimpleName().startsWith("ORDER_BY_"));
      };
      final Consumer<JvmFeature> _function_3 = (JvmFeature feature) -> {
        founder.found = true;
        final String proposal_1 = this.getValueConverter().toString(feature.getSimpleName(), "IDENT").substring(9);
        InputOutput.<String>println(proposal_1);
        acceptor.accept(this.createCompletionProposal(proposal_1, context));
      };
      IterableExtensions.<JvmFeature>filter(IterableExtensions.<JvmFeature>filter(IterableExtensions.<JvmFeature>filter(type.getAllFeatures(), _function), _function_1), _function_2).forEach(_function_3);
      if ((!founder.found)) {
        final Iterable<JvmDeclaredType> nestedTypes = type.findAllNestedTypesByName("Order");
        if ((((!Objects.equal(nestedTypes, null)) && (!IterableExtensions.isEmpty(nestedTypes))) && (IterableExtensions.<JvmDeclaredType>head(nestedTypes) instanceof JvmEnumerationType))) {
          JvmDeclaredType _head = IterableExtensions.<JvmDeclaredType>head(nestedTypes);
          final JvmEnumerationType enumType = ((JvmEnumerationType) _head);
          final Function1<JvmFeature, Boolean> _function_4 = (JvmFeature it) -> {
            return Boolean.valueOf((it instanceof JvmEnumerationLiteral));
          };
          final Consumer<JvmFeature> _function_5 = (JvmFeature feature) -> {
            final String proposal_1 = this.getValueConverter().toString(feature.getSimpleName(), "IDENT");
            InputOutput.<String>println(proposal_1);
            acceptor.accept(this.createCompletionProposal(proposal_1, context));
          };
          IterableExtensions.<JvmFeature>filter(enumType.getAllFeatures(), _function_4).forEach(_function_5);
        }
      }
    } else {
      Resource _eResource = model.eResource();
      URI _uRI = null;
      if (_eResource!=null) {
        _uRI=_eResource.getURI();
      }
      final URI uri = _uRI;
      final String clazz = pojoDefinition.getQualifiedName();
      final Map<String, String> orders = this.pojoResolver.getOrders(clazz, uri);
      boolean _notEquals_1 = (!Objects.equal(orders, null));
      if (_notEquals_1) {
        final Consumer<String> _function_6 = (String order) -> {
          final String proposal_1 = this.getValueConverter().toString(order, "IDENT");
          acceptor.accept(this.createCompletionProposal(proposal_1, context));
        };
        orders.values().forEach(_function_6);
      }
    }
  }
}
