/*
 * generated by Xtext 2.12.0
 */
package org.sqlproc.meta.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sqlproc.meta.processorMeta.AnnotationAssignement;
import org.sqlproc.meta.processorMeta.AnnotationDefinitionModel;
import org.sqlproc.meta.processorMeta.Artifacts;
import org.sqlproc.meta.processorMeta.Column;
import org.sqlproc.meta.processorMeta.ColumnAssignement;
import org.sqlproc.meta.processorMeta.ColumnTypeAssignement;
import org.sqlproc.meta.processorMeta.Constant;
import org.sqlproc.meta.processorMeta.ConstantOperator;
import org.sqlproc.meta.processorMeta.DaogenProperty;
import org.sqlproc.meta.processorMeta.DatabaseCatalogAssignement;
import org.sqlproc.meta.processorMeta.DatabaseColumn;
import org.sqlproc.meta.processorMeta.DatabaseMetaInfoAssignement;
import org.sqlproc.meta.processorMeta.DatabaseProperty;
import org.sqlproc.meta.processorMeta.DatabaseSchemaAssignement;
import org.sqlproc.meta.processorMeta.DatabaseTable;
import org.sqlproc.meta.processorMeta.DatabaseTypeAssignement;
import org.sqlproc.meta.processorMeta.DebugLevelAssignement;
import org.sqlproc.meta.processorMeta.DriverMetaInfoAssignement;
import org.sqlproc.meta.processorMeta.DriverMethodOutputAssignement;
import org.sqlproc.meta.processorMeta.ExportAssignement;
import org.sqlproc.meta.processorMeta.ExtendedColumn;
import org.sqlproc.meta.processorMeta.ExtendedColumnName;
import org.sqlproc.meta.processorMeta.ExtendedMappingItem;
import org.sqlproc.meta.processorMeta.ExtendsAssignement;
import org.sqlproc.meta.processorMeta.ExtendsAssignementGenerics;
import org.sqlproc.meta.processorMeta.FunctionDefinitionModel;
import org.sqlproc.meta.processorMeta.FunctionPojoAssignement;
import org.sqlproc.meta.processorMeta.Identifier;
import org.sqlproc.meta.processorMeta.IdentifierOperator;
import org.sqlproc.meta.processorMeta.IfMetaSql;
import org.sqlproc.meta.processorMeta.IfSql;
import org.sqlproc.meta.processorMeta.IfSqlBool;
import org.sqlproc.meta.processorMeta.IfSqlCond;
import org.sqlproc.meta.processorMeta.IfSqlFragment;
import org.sqlproc.meta.processorMeta.ImplementsAssignement;
import org.sqlproc.meta.processorMeta.ImplementsAssignementGenerics;
import org.sqlproc.meta.processorMeta.ImportAssignement;
import org.sqlproc.meta.processorMeta.InheritanceAssignement;
import org.sqlproc.meta.processorMeta.JoinTableAssignement;
import org.sqlproc.meta.processorMeta.ManyToManyAssignement;
import org.sqlproc.meta.processorMeta.Mapping;
import org.sqlproc.meta.processorMeta.MappingColumn;
import org.sqlproc.meta.processorMeta.MappingColumnName;
import org.sqlproc.meta.processorMeta.MappingItem;
import org.sqlproc.meta.processorMeta.MappingRule;
import org.sqlproc.meta.processorMeta.MetaSql;
import org.sqlproc.meta.processorMeta.MetaSqlTypeAssignement;
import org.sqlproc.meta.processorMeta.MetaStatement;
import org.sqlproc.meta.processorMeta.MetaTypeAssignement;
import org.sqlproc.meta.processorMeta.MetagenProperty;
import org.sqlproc.meta.processorMeta.OptionalFeature;
import org.sqlproc.meta.processorMeta.OrdSql;
import org.sqlproc.meta.processorMeta.OrdSql2;
import org.sqlproc.meta.processorMeta.PojoDefinitionModel;
import org.sqlproc.meta.processorMeta.PojoType;
import org.sqlproc.meta.processorMeta.PojogenProperty;
import org.sqlproc.meta.processorMeta.ProcedureDefinitionModel;
import org.sqlproc.meta.processorMeta.ProcedurePojoAssignement;
import org.sqlproc.meta.processorMeta.ProcessorMetaPackage;
import org.sqlproc.meta.processorMeta.Property;
import org.sqlproc.meta.processorMeta.PropertyCondition;
import org.sqlproc.meta.processorMeta.ShowColumnTypeAssignement;
import org.sqlproc.meta.processorMeta.Sql;
import org.sqlproc.meta.processorMeta.SqlFragment;
import org.sqlproc.meta.processorMeta.SqlTypeAssignement;
import org.sqlproc.meta.processorMeta.TableAssignement;
import org.sqlproc.meta.processorMeta.TableDefinitionModel;
import org.sqlproc.meta.processorMeta.ValueType;
import org.sqlproc.meta.services.ProcessorMetaGrammarAccess;

@SuppressWarnings("all")
public class ProcessorMetaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ProcessorMetaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ProcessorMetaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ProcessorMetaPackage.ANNOTATION_ASSIGNEMENT:
				sequence_AnnotationAssignement(context, (AnnotationAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.ANNOTATION_DEFINITION_MODEL:
				sequence_AnnotationDefinitionModel(context, (AnnotationDefinitionModel) semanticObject); 
				return; 
			case ProcessorMetaPackage.ARTIFACTS:
				sequence_Artifacts(context, (Artifacts) semanticObject); 
				return; 
			case ProcessorMetaPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case ProcessorMetaPackage.COLUMN_ASSIGNEMENT:
				sequence_ColumnAssignement(context, (ColumnAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.COLUMN_TYPE_ASSIGNEMENT:
				sequence_ColumnTypeAssignement(context, (ColumnTypeAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case ProcessorMetaPackage.CONSTANT_OPERATOR:
				sequence_ConstantOperator(context, (ConstantOperator) semanticObject); 
				return; 
			case ProcessorMetaPackage.DAOGEN_PROPERTY:
				sequence_DaogenProperty(context, (DaogenProperty) semanticObject); 
				return; 
			case ProcessorMetaPackage.DATABASE_CATALOG_ASSIGNEMENT:
				sequence_DatabaseCatalogAssignement(context, (DatabaseCatalogAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.DATABASE_COLUMN:
				sequence_DatabaseColumn(context, (DatabaseColumn) semanticObject); 
				return; 
			case ProcessorMetaPackage.DATABASE_META_INFO_ASSIGNEMENT:
				sequence_DatabaseMetaInfoAssignement(context, (DatabaseMetaInfoAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.DATABASE_PROPERTY:
				sequence_DatabaseProperty(context, (DatabaseProperty) semanticObject); 
				return; 
			case ProcessorMetaPackage.DATABASE_SCHEMA_ASSIGNEMENT:
				sequence_DatabaseSchemaAssignement(context, (DatabaseSchemaAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.DATABASE_TABLE:
				sequence_DatabaseTable(context, (DatabaseTable) semanticObject); 
				return; 
			case ProcessorMetaPackage.DATABASE_TYPE_ASSIGNEMENT:
				sequence_DatabaseTypeAssignement(context, (DatabaseTypeAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.DEBUG_LEVEL_ASSIGNEMENT:
				sequence_DebugLevelAssignement(context, (DebugLevelAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.DRIVER_META_INFO_ASSIGNEMENT:
				sequence_DriverMetaInfoAssignement(context, (DriverMetaInfoAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.DRIVER_METHOD_OUTPUT_ASSIGNEMENT:
				sequence_DriverMethodOutputAssignement(context, (DriverMethodOutputAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.EXPORT_ASSIGNEMENT:
				sequence_ExportAssignement(context, (ExportAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.EXTENDED_COLUMN:
				sequence_ExtendedColumn(context, (ExtendedColumn) semanticObject); 
				return; 
			case ProcessorMetaPackage.EXTENDED_COLUMN_NAME:
				sequence_ExtendedColumnName(context, (ExtendedColumnName) semanticObject); 
				return; 
			case ProcessorMetaPackage.EXTENDED_MAPPING_ITEM:
				sequence_ExtendedMappingItem(context, (ExtendedMappingItem) semanticObject); 
				return; 
			case ProcessorMetaPackage.EXTENDS_ASSIGNEMENT:
				sequence_ExtendsAssignement(context, (ExtendsAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.EXTENDS_ASSIGNEMENT_GENERICS:
				sequence_ExtendsAssignementGenerics(context, (ExtendsAssignementGenerics) semanticObject); 
				return; 
			case ProcessorMetaPackage.FUNCTION_DEFINITION_MODEL:
				sequence_FunctionDefinitionModel(context, (FunctionDefinitionModel) semanticObject); 
				return; 
			case ProcessorMetaPackage.FUNCTION_POJO_ASSIGNEMENT:
				sequence_FunctionPojoAssignement(context, (FunctionPojoAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.IDENTIFIER:
				sequence_Identifier(context, (Identifier) semanticObject); 
				return; 
			case ProcessorMetaPackage.IDENTIFIER_OPERATOR:
				sequence_IdentifierOperator(context, (IdentifierOperator) semanticObject); 
				return; 
			case ProcessorMetaPackage.IF_META_SQL:
				sequence_IfMetaSql(context, (IfMetaSql) semanticObject); 
				return; 
			case ProcessorMetaPackage.IF_SQL:
				sequence_IfSql(context, (IfSql) semanticObject); 
				return; 
			case ProcessorMetaPackage.IF_SQL_BOOL:
				sequence_IfSqlBool(context, (IfSqlBool) semanticObject); 
				return; 
			case ProcessorMetaPackage.IF_SQL_COND:
				sequence_IfSqlCond(context, (IfSqlCond) semanticObject); 
				return; 
			case ProcessorMetaPackage.IF_SQL_FRAGMENT:
				sequence_IfSqlFragment(context, (IfSqlFragment) semanticObject); 
				return; 
			case ProcessorMetaPackage.IMPLEMENTS_ASSIGNEMENT:
				sequence_ImplementsAssignement(context, (ImplementsAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.IMPLEMENTS_ASSIGNEMENT_GENERICS:
				sequence_ImplementsAssignementGenerics(context, (ImplementsAssignementGenerics) semanticObject); 
				return; 
			case ProcessorMetaPackage.IMPORT_ASSIGNEMENT:
				sequence_ImportAssignement(context, (ImportAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.INHERITANCE_ASSIGNEMENT:
				sequence_InheritanceAssignement(context, (InheritanceAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.JOIN_TABLE_ASSIGNEMENT:
				sequence_JoinTableAssignement(context, (JoinTableAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.MANY_TO_MANY_ASSIGNEMENT:
				sequence_ManyToManyAssignement(context, (ManyToManyAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case ProcessorMetaPackage.MAPPING_COLUMN:
				sequence_MappingColumn(context, (MappingColumn) semanticObject); 
				return; 
			case ProcessorMetaPackage.MAPPING_COLUMN_NAME:
				sequence_MappingColumnName(context, (MappingColumnName) semanticObject); 
				return; 
			case ProcessorMetaPackage.MAPPING_ITEM:
				sequence_MappingItem(context, (MappingItem) semanticObject); 
				return; 
			case ProcessorMetaPackage.MAPPING_RULE:
				sequence_MappingRule(context, (MappingRule) semanticObject); 
				return; 
			case ProcessorMetaPackage.META_SQL:
				sequence_MetaSql(context, (MetaSql) semanticObject); 
				return; 
			case ProcessorMetaPackage.META_SQL_TYPE_ASSIGNEMENT:
				sequence_MetaSqlTypeAssignement(context, (MetaSqlTypeAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.META_STATEMENT:
				sequence_MetaStatement(context, (MetaStatement) semanticObject); 
				return; 
			case ProcessorMetaPackage.META_TYPE_ASSIGNEMENT:
				sequence_MetaTypeAssignement(context, (MetaTypeAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.METAGEN_PROPERTY:
				sequence_MetagenProperty(context, (MetagenProperty) semanticObject); 
				return; 
			case ProcessorMetaPackage.OPTIONAL_FEATURE:
				sequence_OptionalFeature(context, (OptionalFeature) semanticObject); 
				return; 
			case ProcessorMetaPackage.ORD_SQL:
				sequence_OrdSql(context, (OrdSql) semanticObject); 
				return; 
			case ProcessorMetaPackage.ORD_SQL2:
				sequence_OrdSql2(context, (OrdSql2) semanticObject); 
				return; 
			case ProcessorMetaPackage.POJO_DEFINITION_MODEL:
				sequence_PojoDefinitionModel(context, (PojoDefinitionModel) semanticObject); 
				return; 
			case ProcessorMetaPackage.POJO_TYPE:
				sequence_PojoType(context, (PojoType) semanticObject); 
				return; 
			case ProcessorMetaPackage.POJOGEN_PROPERTY:
				sequence_PojogenProperty(context, (PojogenProperty) semanticObject); 
				return; 
			case ProcessorMetaPackage.PROCEDURE_DEFINITION_MODEL:
				sequence_ProcedureDefinitionModel(context, (ProcedureDefinitionModel) semanticObject); 
				return; 
			case ProcessorMetaPackage.PROCEDURE_POJO_ASSIGNEMENT:
				sequence_ProcedurePojoAssignement(context, (ProcedurePojoAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case ProcessorMetaPackage.PROPERTY_CONDITION:
				sequence_PropertyCondition(context, (PropertyCondition) semanticObject); 
				return; 
			case ProcessorMetaPackage.SHOW_COLUMN_TYPE_ASSIGNEMENT:
				sequence_ShowColumnTypeAssignement(context, (ShowColumnTypeAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.SQL:
				sequence_Sql(context, (Sql) semanticObject); 
				return; 
			case ProcessorMetaPackage.SQL_FRAGMENT:
				sequence_SqlFragment(context, (SqlFragment) semanticObject); 
				return; 
			case ProcessorMetaPackage.SQL_TYPE_ASSIGNEMENT:
				sequence_SqlTypeAssignement(context, (SqlTypeAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.TABLE_ASSIGNEMENT:
				sequence_TableAssignement(context, (TableAssignement) semanticObject); 
				return; 
			case ProcessorMetaPackage.TABLE_DEFINITION_MODEL:
				sequence_TableDefinitionModel(context, (TableDefinitionModel) semanticObject); 
				return; 
			case ProcessorMetaPackage.VALUE_TYPE:
				sequence_ValueType(context, (ValueType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnnotationAssignement returns AnnotationAssignement
	 *
	 * Constraint:
	 *     (annotations+=[AnnotationDefinitionModel|IDENT] annotations+=[AnnotationDefinitionModel|IDENT]* dbTables+=IDENT* dbNotTables+=IDENT*)
	 */
	protected void sequence_AnnotationAssignement(ISerializationContext context, AnnotationAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationDefinitionModel returns AnnotationDefinitionModel
	 *
	 * Constraint:
	 *     (name=IDENT (class=IDENT | class=IDENT_DOT | classx=[JvmType|QualifiedName]))
	 */
	protected void sequence_AnnotationDefinitionModel(ISerializationContext context, AnnotationDefinitionModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Artifacts returns Artifacts
	 *
	 * Constraint:
	 *     (
	 *         properties+=Property | 
	 *         pojos+=PojoDefinitionModel | 
	 *         annotations+=AnnotationDefinitionModel | 
	 *         tables+=TableDefinitionModel | 
	 *         procedures+=ProcedureDefinitionModel | 
	 *         functions+=FunctionDefinitionModel | 
	 *         statements+=MetaStatement | 
	 *         mappings+=MappingRule | 
	 *         features+=OptionalFeature
	 *     )*
	 */
	protected void sequence_Artifacts(ISerializationContext context, Artifacts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnAssignement returns ColumnAssignement
	 *
	 * Constraint:
	 *     (dbColumn=IDENT newName=IDENT)
	 */
	protected void sequence_ColumnAssignement(ISerializationContext context, ColumnAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.COLUMN_ASSIGNEMENT__DB_COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.COLUMN_ASSIGNEMENT__DB_COLUMN));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.COLUMN_ASSIGNEMENT__NEW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.COLUMN_ASSIGNEMENT__NEW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAssignementAccess().getDbColumnIDENTTerminalRuleCall_0_0(), semanticObject.getDbColumn());
		feeder.accept(grammarAccess.getColumnAssignementAccess().getNewNameIDENTTerminalRuleCall_2_0(), semanticObject.getNewName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColumnTypeAssignement returns ColumnTypeAssignement
	 *
	 * Constraint:
	 *     (dbColumn=IDENT type=PojoType)
	 */
	protected void sequence_ColumnTypeAssignement(ISerializationContext context, ColumnTypeAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.COLUMN_TYPE_ASSIGNEMENT__DB_COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.COLUMN_TYPE_ASSIGNEMENT__DB_COLUMN));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.COLUMN_TYPE_ASSIGNEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.COLUMN_TYPE_ASSIGNEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnTypeAssignementAccess().getDbColumnIDENTTerminalRuleCall_0_0(), semanticObject.getDbColumn());
		feeder.accept(grammarAccess.getColumnTypeAssignementAccess().getTypePojoTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (columns+=ExtendedColumn columns+=ExtendedColumn*)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstantOperator returns ConstantOperator
	 *
	 * Constraint:
	 *     (name=IDENT | name=EQUALS)
	 */
	protected void sequence_ConstantOperator(ISerializationContext context, ConstantOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     ((case=PLUS | case=MINUS)? (name=IDENT | name=IDENT_DOT) (modifiers+=Modifier modifiers+=Modifier*)?)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DaogenProperty returns DaogenProperty
	 *
	 * Constraint:
	 *     (
	 *         (name='ignore-tables' dbTables+=IDENT+) | 
	 *         (name='only-tables' dbTables+=IDENT*) | 
	 *         (name='implements-interfaces' toImplements=ImplementsAssignement) | 
	 *         (name='extends-class' toExtends=ExtendsAssignement) | 
	 *         (name='implements-interfaces-generics' toImplementsGenerics=ImplementsAssignementGenerics) | 
	 *         (name='extends-class-generics' toExtendsGenerics=ExtendsAssignementGenerics) | 
	 *         name='make-it-final' | 
	 *         (name='function-result' dbFunction=IDENT resultType=PojoType) | 
	 *         (name='debug-level' debug=DebugLevelAssignement) | 
	 *         (name='active-filter' activeFilter=ValueType) | 
	 *         (name='package' pckg=QualifiedName) | 
	 *         (name='implementation-package' implPckg=QualifiedName) | 
	 *         (name='dao-annotations' columnAnnotations=AnnotationAssignement)
	 *     )
	 */
	protected void sequence_DaogenProperty(ISerializationContext context, DaogenProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseCatalogAssignement returns DatabaseCatalogAssignement
	 *
	 * Constraint:
	 *     dbCatalog=ValueType
	 */
	protected void sequence_DatabaseCatalogAssignement(ISerializationContext context, DatabaseCatalogAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.DATABASE_CATALOG_ASSIGNEMENT__DB_CATALOG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.DATABASE_CATALOG_ASSIGNEMENT__DB_CATALOG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatabaseCatalogAssignementAccess().getDbCatalogValueTypeParserRuleCall_0(), semanticObject.getDbCatalog());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseColumn returns DatabaseColumn
	 *
	 * Constraint:
	 *     (name=IDENT | name=IDENT_DOT)
	 */
	protected void sequence_DatabaseColumn(ISerializationContext context, DatabaseColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseMetaInfoAssignement returns DatabaseMetaInfoAssignement
	 *
	 * Constraint:
	 *     dbMetaInfo=ValueType
	 */
	protected void sequence_DatabaseMetaInfoAssignement(ISerializationContext context, DatabaseMetaInfoAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.DATABASE_META_INFO_ASSIGNEMENT__DB_META_INFO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.DATABASE_META_INFO_ASSIGNEMENT__DB_META_INFO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatabaseMetaInfoAssignementAccess().getDbMetaInfoValueTypeParserRuleCall_0(), semanticObject.getDbMetaInfo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseProperty returns DatabaseProperty
	 *
	 * Constraint:
	 *     (
	 *         name='is-online' | 
	 *         name='is-offline' | 
	 *         (name='has-url' dbUrl=ValueType) | 
	 *         (name='login-username' dbUsername=ValueType) | 
	 *         (name='login-password' dbPassword=ValueType) | 
	 *         (name='in-catalog' dbCatalog=DatabaseCatalogAssignement) | 
	 *         (name='active-schema' dbSchema=DatabaseSchemaAssignement) | 
	 *         (name='jdbc-driver' dbDriver=PojoType) | 
	 *         (name='ddl-create' dbExecuteBefore=ValueType) | 
	 *         (name='ddl-drop' dbExecuteAfter=ValueType) | 
	 *         (name='index-types' dbIndexTypes=ValueType) | 
	 *         name='skip-indexes' | 
	 *         name='skip-functions-procedures' | 
	 *         name='skip-check-constraints' | 
	 *         (name='is-of-type' dbType=DatabaseTypeAssignement) | 
	 *         (name='show-database-info' dbMetaInfo=DatabaseMetaInfoAssignement) | 
	 *         (name='show-driver-info' dbDriverInfo=DriverMetaInfoAssignement) | 
	 *         (name='show-driver-output' dbMethodsCalls+=DriverMethodOutputAssignement+) | 
	 *         (name='debug-level' debug=DebugLevelAssignement) | 
	 *         name='take-comments' | 
	 *         name='lowercase-names' | 
	 *         name='uppercase-names'
	 *     )
	 */
	protected void sequence_DatabaseProperty(ISerializationContext context, DatabaseProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseSchemaAssignement returns DatabaseSchemaAssignement
	 *
	 * Constraint:
	 *     dbSchema=ValueType
	 */
	protected void sequence_DatabaseSchemaAssignement(ISerializationContext context, DatabaseSchemaAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.DATABASE_SCHEMA_ASSIGNEMENT__DB_SCHEMA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.DATABASE_SCHEMA_ASSIGNEMENT__DB_SCHEMA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatabaseSchemaAssignementAccess().getDbSchemaValueTypeParserRuleCall_0(), semanticObject.getDbSchema());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseTable returns DatabaseTable
	 *
	 * Constraint:
	 *     (name=IDENT | name=IDENT_DOT)
	 */
	protected void sequence_DatabaseTable(ISerializationContext context, DatabaseTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseTypeAssignement returns DatabaseTypeAssignement
	 *
	 * Constraint:
	 *     dbType=IDENT
	 */
	protected void sequence_DatabaseTypeAssignement(ISerializationContext context, DatabaseTypeAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.DATABASE_TYPE_ASSIGNEMENT__DB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.DATABASE_TYPE_ASSIGNEMENT__DB_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatabaseTypeAssignementAccess().getDbTypeIDENTTerminalRuleCall_0(), semanticObject.getDbType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DebugLevelAssignement returns DebugLevelAssignement
	 *
	 * Constraint:
	 *     (debug=IDENT scope=IDENT?)
	 */
	protected void sequence_DebugLevelAssignement(ISerializationContext context, DebugLevelAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DriverMetaInfoAssignement returns DriverMetaInfoAssignement
	 *
	 * Constraint:
	 *     dbDriverInfo=ValueType
	 */
	protected void sequence_DriverMetaInfoAssignement(ISerializationContext context, DriverMetaInfoAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.DRIVER_META_INFO_ASSIGNEMENT__DB_DRIVER_INFO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.DRIVER_META_INFO_ASSIGNEMENT__DB_DRIVER_INFO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDriverMetaInfoAssignementAccess().getDbDriverInfoValueTypeParserRuleCall_0(), semanticObject.getDbDriverInfo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DriverMethodOutputAssignement returns DriverMethodOutputAssignement
	 *
	 * Constraint:
	 *     (driverMethod=IDENT callOutput=ValueType)
	 */
	protected void sequence_DriverMethodOutputAssignement(ISerializationContext context, DriverMethodOutputAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.DRIVER_METHOD_OUTPUT_ASSIGNEMENT__DRIVER_METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.DRIVER_METHOD_OUTPUT_ASSIGNEMENT__DRIVER_METHOD));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.DRIVER_METHOD_OUTPUT_ASSIGNEMENT__CALL_OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.DRIVER_METHOD_OUTPUT_ASSIGNEMENT__CALL_OUTPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDriverMethodOutputAssignementAccess().getDriverMethodIDENTTerminalRuleCall_0_0(), semanticObject.getDriverMethod());
		feeder.accept(grammarAccess.getDriverMethodOutputAssignementAccess().getCallOutputValueTypeParserRuleCall_2_0(), semanticObject.getCallOutput());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExportAssignement returns ExportAssignement
	 *
	 * Constraint:
	 *     (dbColumn=IDENT fkTable=IDENT fkColumn=IDENT?)
	 */
	protected void sequence_ExportAssignement(ISerializationContext context, ExportAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendedColumnName returns ExtendedColumnName
	 *
	 * Constraint:
	 *     (name=IDENT | name=NUMBER | name=IDENT_DOT)
	 */
	protected void sequence_ExtendedColumnName(ISerializationContext context, ExtendedColumnName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendedColumn returns ExtendedColumn
	 *
	 * Constraint:
	 *     (col=ExtendedColumnName (modifiers+=Modifier modifiers+=Modifier*)?)
	 */
	protected void sequence_ExtendedColumn(ISerializationContext context, ExtendedColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendedMappingItem returns ExtendedMappingItem
	 *
	 * Constraint:
	 *     (attr=MappingColumnName (modifiers+=MappingItemModifier modifiers+=MappingItemModifier*)?)
	 */
	protected void sequence_ExtendedMappingItem(ISerializationContext context, ExtendedMappingItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendsAssignementGenerics returns ExtendsAssignementGenerics
	 *
	 * Constraint:
	 *     (toExtends=PojoType dbTables+=IDENT* dbNotTables+=IDENT*)
	 */
	protected void sequence_ExtendsAssignementGenerics(ISerializationContext context, ExtendsAssignementGenerics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendsAssignement returns ExtendsAssignement
	 *
	 * Constraint:
	 *     (toExtends=PojoType dbTables+=IDENT* dbNotTables+=IDENT*)
	 */
	protected void sequence_ExtendsAssignement(ISerializationContext context, ExtendsAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionModel returns FunctionDefinitionModel
	 *
	 * Constraint:
	 *     (name=IDENT table=IDENT)
	 */
	protected void sequence_FunctionDefinitionModel(ISerializationContext context, FunctionDefinitionModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_DEFINITION_MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_DEFINITION_MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_DEFINITION_MODEL__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_DEFINITION_MODEL__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionDefinitionModelAccess().getNameIDENTTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionDefinitionModelAccess().getTableIDENTTerminalRuleCall_2_0(), semanticObject.getTable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPojoAssignement returns FunctionPojoAssignement
	 *
	 * Constraint:
	 *     (dbFunction=IDENT pojo=PojoType)
	 */
	protected void sequence_FunctionPojoAssignement(ISerializationContext context, FunctionPojoAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_POJO_ASSIGNEMENT__DB_FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_POJO_ASSIGNEMENT__DB_FUNCTION));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_POJO_ASSIGNEMENT__POJO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.FUNCTION_POJO_ASSIGNEMENT__POJO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionPojoAssignementAccess().getDbFunctionIDENTTerminalRuleCall_0_0(), semanticObject.getDbFunction());
		feeder.accept(grammarAccess.getFunctionPojoAssignementAccess().getPojoPojoTypeParserRuleCall_2_0(), semanticObject.getPojo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdentifierOperator returns IdentifierOperator
	 *
	 * Constraint:
	 *     (name=IDENT | name=EQUALS)
	 */
	protected void sequence_IdentifierOperator(ISerializationContext context, IdentifierOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifier returns Identifier
	 *
	 * Constraint:
	 *     (
	 *         (mode=EQUALS | mode=LESS_THAN | mode=MORE_THAN)? 
	 *         (case=PLUS | case=MINUS)? 
	 *         (name=IDENT | name=NUMBER | name=IDENT_DOT) 
	 *         (modifiers+=Modifier modifiers+=Modifier*)?
	 *     )
	 */
	protected void sequence_Identifier(ISerializationContext context, Identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfMetaSql returns IfMetaSql
	 *
	 * Constraint:
	 *     (
	 *         (ifs+=IfSql ifs+=IfSql*) | 
	 *         (type=QUESTI cond=IfSqlCond ifs+=IfSql ifs+=IfSql*) | 
	 *         (type=BAND ifs+=IfSql ifs+=IfSql*) | 
	 *         (type=BOR ifs+=IfSql ifs+=IfSql*)
	 *     )
	 */
	protected void sequence_IfMetaSql(ISerializationContext context, IfMetaSql semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfSqlBool returns IfSqlBool
	 *
	 * Constraint:
	 *     ((not?=NOT? cnst=Constant) | (not?=NOT? ident=Identifier) | (not?=NOT? cond=IfSqlCond))
	 */
	protected void sequence_IfSqlBool(ISerializationContext context, IfSqlBool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfSqlCond returns IfSqlCond
	 *
	 * Constraint:
	 *     (bool1=IfSqlBool ((oper+=AND | oper+=OR) bool2+=IfSqlBool)*)
	 */
	protected void sequence_IfSqlCond(ISerializationContext context, IfSqlCond semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfSqlFragment returns IfSqlFragment
	 *
	 * Constraint:
	 *     (
	 *         value=IfSqlValue | 
	 *         col=Column | 
	 *         cnst=Constant | 
	 *         ident=Identifier | 
	 *         cnstOper=ConstantOperator | 
	 *         identOper=IdentifierOperator | 
	 *         dbtab=DatabaseTable | 
	 *         dbcol=DatabaseColumn | 
	 *         meta=IfMetaSql
	 *     )
	 */
	protected void sequence_IfSqlFragment(ISerializationContext context, IfSqlFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfSql returns IfSql
	 *
	 * Constraint:
	 *     sqls+=IfSqlFragment+
	 */
	protected void sequence_IfSql(ISerializationContext context, IfSql semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplementsAssignementGenerics returns ImplementsAssignementGenerics
	 *
	 * Constraint:
	 *     (toImplement=PojoType dbTables+=IDENT* dbNotTables+=IDENT*)
	 */
	protected void sequence_ImplementsAssignementGenerics(ISerializationContext context, ImplementsAssignementGenerics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplementsAssignement returns ImplementsAssignement
	 *
	 * Constraint:
	 *     (toImplement=PojoType dbTables+=IDENT* dbNotTables+=IDENT*)
	 */
	protected void sequence_ImplementsAssignement(ISerializationContext context, ImplementsAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportAssignement returns ImportAssignement
	 *
	 * Constraint:
	 *     (dbColumn=IDENT pkTable=IDENT pkColumn=IDENT?)
	 */
	protected void sequence_ImportAssignement(ISerializationContext context, ImportAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InheritanceAssignement returns InheritanceAssignement
	 *
	 * Constraint:
	 *     (discriminator=IDENT dbTable=IDENT dbColumns+=IDENT+)
	 */
	protected void sequence_InheritanceAssignement(ISerializationContext context, InheritanceAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JoinTableAssignement returns JoinTableAssignement
	 *
	 * Constraint:
	 *     (dbTable=IDENT dbTables+=IDENT+)
	 */
	protected void sequence_JoinTableAssignement(ISerializationContext context, JoinTableAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ManyToManyAssignement returns ManyToManyAssignement
	 *
	 * Constraint:
	 *     (pkColumn=IDENT pkTable=IDENT fkColumn=IDENT?)
	 */
	protected void sequence_ManyToManyAssignement(ISerializationContext context, ManyToManyAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingColumnName returns MappingColumnName
	 *
	 * Constraint:
	 *     (name=IDENT | name=IDENT_DOT | name=NUMBER)
	 */
	protected void sequence_MappingColumnName(ISerializationContext context, MappingColumnName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingColumn returns MappingColumn
	 *
	 * Constraint:
	 *     (items+=ExtendedMappingItem items+=ExtendedMappingItem*)
	 */
	protected void sequence_MappingColumn(ISerializationContext context, MappingColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingItem returns MappingItem
	 *
	 * Constraint:
	 *     ((name=IDENT | name=NUMBER) attr=MappingColumn?)
	 */
	protected void sequence_MappingItem(ISerializationContext context, MappingItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingRule returns MappingRule
	 *
	 * Constraint:
	 *     (name=IDENT type=MAPPING_TYPE modifiers+=MappingRuleModifier* mapping=Mapping)
	 */
	protected void sequence_MappingRule(ISerializationContext context, MappingRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     (mappingItems+=MappingItem mappingItems+=MappingItem*)
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaSqlTypeAssignement returns MetaSqlTypeAssignement
	 *
	 * Constraint:
	 *     (sqlType=ValueType type=IDENT extension=IDENT?)
	 */
	protected void sequence_MetaSqlTypeAssignement(ISerializationContext context, MetaSqlTypeAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaSql returns MetaSql
	 *
	 * Constraint:
	 *     (
	 *         (ifs+=IfSql ifs+=IfSql*) | 
	 *         (type=QUESTI cond=IfSqlCond ifs+=IfSql ifs+=IfSql*) | 
	 *         (type=BAND ifs+=IfSql ifs+=IfSql*) | 
	 *         (type=BOR ifs+=IfSql ifs+=IfSql*) | 
	 *         (type=EQUALS ftype=IDENT ifs+=IfSql) | 
	 *         (type=HASH ord=OrdSql)
	 *     )
	 */
	protected void sequence_MetaSql(ISerializationContext context, MetaSql semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaStatement returns MetaStatement
	 *
	 * Constraint:
	 *     (name=IDENT type=STATEMENT_TYPE modifiers+=StatementModifier* statement=Sql)
	 */
	protected void sequence_MetaStatement(ISerializationContext context, MetaStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaTypeAssignement returns MetaTypeAssignement
	 *
	 * Constraint:
	 *     (dbColumn=IDENT type=IDENT extension=IDENT?)
	 */
	protected void sequence_MetaTypeAssignement(ISerializationContext context, MetaTypeAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetagenProperty returns MetagenProperty
	 *
	 * Constraint:
	 *     (
	 *         (name='global-sequence' sequence=IDENT type=IDENT? dbTables+=IDENT* dbNotTables+=IDENT*) | 
	 *         (name='table-sequence' dbTable=IDENT sequence=IDENT type=IDENT?) | 
	 *         (name='global-identity' (identity=IDENT type=IDENT?)? dbTables+=IDENT* dbNotTables+=IDENT*) | 
	 *         (name='table-identity' dbTable=IDENT identity=IDENT type=IDENT?) | 
	 *         (name='sqltype-meta-type' sqlTypes+=MetaSqlTypeAssignement+) | 
	 *         (name='column-meta-type' dbTable=IDENT metaTypes+=MetaTypeAssignement+) | 
	 *         (name='statement-meta-type' dbStatement=IDENT metaTypes+=MetaTypeAssignement+) | 
	 *         name='make-it-final' | 
	 *         (name='like-columns' (dbTable=IDENT dbColumns+=IDENT+)?) | 
	 *         (name='not-like-columns' (dbTable=IDENT dbColumns+=IDENT+)?) | 
	 *         name='generate-sequences' | 
	 *         name='generate-identities' | 
	 *         name='generate-idgenerators' | 
	 *         name='generate-default-idgenerators' | 
	 *         (name='function-result' dbFunction=IDENT type=IDENT) | 
	 *         (name='function-result-set' dbFunction=IDENT dbTable=IDENT) | 
	 *         (name='procedure-result-set' dbProcedure=IDENT dbTable=IDENT) | 
	 *         (name='debug-level' debug=DebugLevelAssignement) | 
	 *         name='generate-operators' | 
	 *         (name='optimize-insert' dbTables+=IDENT*) | 
	 *         (name='optional-features' dbStatement=IDENT optionalFeatures+=ValueType+) | 
	 *         (name='active-filter' activeFilter=ValueType) | 
	 *         (name='insert-skip-default-values' dbTables+=IDENT* dbNotTables+=IDENT*)
	 *     )
	 */
	protected void sequence_MetagenProperty(ISerializationContext context, MetagenProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionalFeature returns OptionalFeature
	 *
	 * Constraint:
	 *     (name=IDENT type=OPTION_TYPE modifiers+=OptionalFeatureModifier* option=FeatureValue)
	 */
	protected void sequence_OptionalFeature(ISerializationContext context, OptionalFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrdSql2 returns OrdSql2
	 *
	 * Constraint:
	 *     (value=OrdSqlValue | cnst=Constant | ident=Identifier | dbcol=DatabaseColumn)
	 */
	protected void sequence_OrdSql2(ISerializationContext context, OrdSql2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrdSql returns OrdSql
	 *
	 * Constraint:
	 *     ((ident=NUMBER | ident=QualifiedName) sqls+=OrdSql2+)
	 */
	protected void sequence_OrdSql(ISerializationContext context, OrdSql semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PojoDefinitionModel returns PojoDefinitionModel
	 *
	 * Constraint:
	 *     (name=IDENT (class=IDENT | class=IDENT_DOT | classx=[JvmType|QualifiedName]))
	 */
	protected void sequence_PojoDefinitionModel(ISerializationContext context, PojoDefinitionModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PojoType returns PojoType
	 *
	 * Constraint:
	 *     (ident=ValueType | ref=[PojoDefinitionModel|IDENT] | (type=[JvmType|QualifiedName] gtype=[JvmType|QualifiedName]? array?='[]'?))
	 */
	protected void sequence_PojoType(ISerializationContext context, PojoType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PojogenProperty returns PojogenProperty
	 *
	 * Constraint:
	 *     (
	 *         (name='types-sqltypes' sqlTypes+=SqlTypeAssignement+) | 
	 *         (name='types-in-table' dbTable=IDENT sqlTypes+=SqlTypeAssignement+) | 
	 *         (name='types-for-columns' dbTable=IDENT columnTypes+=ColumnTypeAssignement+) | 
	 *         (name='types-for-procedure' dbProcedure=IDENT columnTypes+=ColumnTypeAssignement+) | 
	 *         (name='types-for-function' dbFunction=IDENT columnTypes+=ColumnTypeAssignement+) | 
	 *         (name='show-type-for-column' dbTable=IDENT columnType=ShowColumnTypeAssignement) | 
	 *         (name='show-type-for-procedure' dbProcedure=IDENT columnType=ShowColumnTypeAssignement) | 
	 *         (name='show-type-for-function' dbFunction=IDENT columnType=ShowColumnTypeAssignement) | 
	 *         (name='ignore-tables' dbTables+=IDENT+) | 
	 *         (name='only-tables' dbTables+=IDENT+) | 
	 *         (name='not-abstract-tables' dbTables+=IDENT+) | 
	 *         (name='create-tables' dbTables+=IDENT+) | 
	 *         (name='join-tables' joinTables+=JoinTableAssignement+) | 
	 *         (name='ignore-columns' dbTable=IDENT dbColumns+=IDENT+) | 
	 *         (name='required-columns' dbTable=IDENT dbColumns+=IDENT+) | 
	 *         (name='not-required-columns' dbTable=IDENT dbColumns+=IDENT+) | 
	 *         (name='create-columns' dbTable=IDENT columnTypes+=ColumnTypeAssignement+) | 
	 *         (name='rename-tables' tables+=TableAssignement+) | 
	 *         (name='rename-columns' dbTable=IDENT columns+=ColumnAssignement+) | 
	 *         (name='ignore-one-to-many' dbTable=IDENT exports+=ExportAssignement+) | 
	 *         (name='ignore-many-to-one' dbTable=IDENT imports+=ImportAssignement+) | 
	 *         (name='inherit-many-to-one' dbTable=IDENT imports+=ImportAssignement+) | 
	 *         (name='create-one-to-many' dbTable=IDENT exports+=ExportAssignement+) | 
	 *         (name='create-many-to-one' dbTable=IDENT imports+=ImportAssignement+) | 
	 *         (name='association-one-to-one' dbTable=IDENT imports+=ImportAssignement+) | 
	 *         (name='table-many-to-many' dbTable=IDENT many2s+=ManyToManyAssignement+) | 
	 *         (name='inherit-discriminator' dbTable=IDENT dbColumn=IDENT inheritance+=InheritanceAssignement+) | 
	 *         (name='generate-methods' methods+=IDENT+) | 
	 *         (name='generate-operators' operatorsSuffix=IDENT?) | 
	 *         (name='implements-interfaces' toImplements=ImplementsAssignement) | 
	 *         (name='extends-class' toExtends=ExtendsAssignement) | 
	 *         (name='implements-interfaces-generics' toImplementsGenerics=ImplementsAssignementGenerics) | 
	 *         (name='extends-class-generics' toExtendsGenerics=ExtendsAssignementGenerics) | 
	 *         name='generate-wrappers' | 
	 *         name='generate-validation-annotations' | 
	 *         (name='preserve-foreign-keys' dbTables+=IDENT*) | 
	 *         name='make-it-final' | 
	 *         (name='version-column' version=IDENT dbTables+=IDENT* dbNotTables+=IDENT*) | 
	 *         (name='debug-level' debug=DebugLevelAssignement) | 
	 *         (name='pojos-for-procedures' procPojos+=ProcedurePojoAssignement+) | 
	 *         (name='pojos-for-functions' funPojos+=FunctionPojoAssignement+) | 
	 *         (name='active-filter' activeFilter=ValueType) | 
	 *         (name='package' pckg=QualifiedName) | 
	 *         (name='enum-for-check-constraints' enumName=IDENT dbCheckConstraints+=IDENT+) | 
	 *         (name='column-annotations' dbColumn=IDENT columnAnnotations=AnnotationAssignement) | 
	 *         (name='getter-annotations' dbColumn=IDENT columnAnnotations=AnnotationAssignement) | 
	 *         (name='setter-annotations' dbColumn=IDENT columnAnnotations=AnnotationAssignement) | 
	 *         (name='conflict-annotations' columnAnnotations=AnnotationAssignement) | 
	 *         (name='static-annotations' columnAnnotations=AnnotationAssignement) | 
	 *         (name='constructor-annotations' columnAnnotations=AnnotationAssignement) | 
	 *         (name='pojo-annotations' columnAnnotations=AnnotationAssignement) | 
	 *         name='old-date-time'
	 *     )
	 */
	protected void sequence_PojogenProperty(ISerializationContext context, PojogenProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcedureDefinitionModel returns ProcedureDefinitionModel
	 *
	 * Constraint:
	 *     (name=IDENT table=IDENT)
	 */
	protected void sequence_ProcedureDefinitionModel(ISerializationContext context, ProcedureDefinitionModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureDefinitionModelAccess().getNameIDENTTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProcedureDefinitionModelAccess().getTableIDENTTerminalRuleCall_2_0(), semanticObject.getTable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcedurePojoAssignement returns ProcedurePojoAssignement
	 *
	 * Constraint:
	 *     (dbProcedure=IDENT pojo=PojoType)
	 */
	protected void sequence_ProcedurePojoAssignement(ISerializationContext context, ProcedurePojoAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_POJO_ASSIGNEMENT__DB_PROCEDURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_POJO_ASSIGNEMENT__DB_PROCEDURE));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_POJO_ASSIGNEMENT__POJO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.PROCEDURE_POJO_ASSIGNEMENT__POJO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedurePojoAssignementAccess().getDbProcedureIDENTTerminalRuleCall_0_0(), semanticObject.getDbProcedure());
		feeder.accept(grammarAccess.getProcedurePojoAssignementAccess().getPojoPojoTypeParserRuleCall_2_0(), semanticObject.getPojo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyCondition returns PropertyCondition
	 *
	 * Constraint:
	 *     (name=IDENT value=ValueType)
	 */
	protected void sequence_PropertyCondition(ISerializationContext context, PropertyCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.PROPERTY_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.PROPERTY_CONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.PROPERTY_CONDITION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.PROPERTY_CONDITION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyConditionAccess().getNameIDENTTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyConditionAccess().getValueValueTypeParserRuleCall_6_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (
	 *         condition=PropertyCondition? 
	 *         (
	 *             name='resolve-pojo-on' | 
	 *             name='resolve-pojo-off' | 
	 *             (name='database-' database=DatabaseProperty) | 
	 *             (name='pojogen-' pojogen=PojogenProperty) | 
	 *             (name='metagen-' metagen=MetagenProperty) | 
	 *             (name='daogen-' daogen=DaogenProperty) | 
	 *             (name='replace-all-regex' replaceId=IDENT regex=ValueType) | 
	 *             (name='replace-all-replacement' replaceId=IDENT replacement=ValueType) | 
	 *             (name='replace-text' regex=ValueType replacement=ValueType) | 
	 *             (name='validate-resources' doVerifyResources+=ValueType* doNotVerifyResources+=ValueType*) | 
	 *             name='compress-meta-directives' | 
	 *             name='generate-from-to' | 
	 *             (name='case-format-library' caseFormatLibrary=ValueType) | 
	 *             name='new-pojo-validator' | 
	 *             name='old-pojo-validator'
	 *         )
	 *     )
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShowColumnTypeAssignement returns ShowColumnTypeAssignement
	 *
	 * Constraint:
	 *     (dbColumn=IDENT type=ValueType)
	 */
	protected void sequence_ShowColumnTypeAssignement(ISerializationContext context, ShowColumnTypeAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.SHOW_COLUMN_TYPE_ASSIGNEMENT__DB_COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.SHOW_COLUMN_TYPE_ASSIGNEMENT__DB_COLUMN));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.SHOW_COLUMN_TYPE_ASSIGNEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.SHOW_COLUMN_TYPE_ASSIGNEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShowColumnTypeAssignementAccess().getDbColumnIDENTTerminalRuleCall_0_0(), semanticObject.getDbColumn());
		feeder.accept(grammarAccess.getShowColumnTypeAssignementAccess().getTypeValueTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SqlFragment returns SqlFragment
	 *
	 * Constraint:
	 *     (
	 *         value=SqlValue | 
	 *         col=Column | 
	 *         cnst=Constant | 
	 *         ident=Identifier | 
	 *         cnstOper=ConstantOperator | 
	 *         identOper=IdentifierOperator | 
	 *         meta=MetaSql | 
	 *         dbtab=DatabaseTable | 
	 *         dbcol=DatabaseColumn
	 *     )
	 */
	protected void sequence_SqlFragment(ISerializationContext context, SqlFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SqlTypeAssignement returns SqlTypeAssignement
	 *
	 * Constraint:
	 *     (sqlType=ValueType sqlSize=NUMBER? type=PojoType)
	 */
	protected void sequence_SqlTypeAssignement(ISerializationContext context, SqlTypeAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sql returns Sql
	 *
	 * Constraint:
	 *     sqls+=SqlFragment+
	 */
	protected void sequence_Sql(ISerializationContext context, Sql semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableAssignement returns TableAssignement
	 *
	 * Constraint:
	 *     (dbTable=IDENT newName=IDENT)
	 */
	protected void sequence_TableAssignement(ISerializationContext context, TableAssignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.TABLE_ASSIGNEMENT__DB_TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.TABLE_ASSIGNEMENT__DB_TABLE));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.TABLE_ASSIGNEMENT__NEW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.TABLE_ASSIGNEMENT__NEW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableAssignementAccess().getDbTableIDENTTerminalRuleCall_0_0(), semanticObject.getDbTable());
		feeder.accept(grammarAccess.getTableAssignementAccess().getNewNameIDENTTerminalRuleCall_2_0(), semanticObject.getNewName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TableDefinitionModel returns TableDefinitionModel
	 *
	 * Constraint:
	 *     (name=IDENT table=IDENT)
	 */
	protected void sequence_TableDefinitionModel(ISerializationContext context, TableDefinitionModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableDefinitionModelAccess().getNameIDENTTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTableDefinitionModelAccess().getTableIDENTTerminalRuleCall_2_0(), semanticObject.getTable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValueType returns ValueType
	 *
	 * Constraint:
	 *     (value=STRING_VALUE | number=NUMBER | id=QualifiedName)
	 */
	protected void sequence_ValueType(ISerializationContext context, ValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
