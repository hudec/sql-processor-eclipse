/**
 * generated by Xtext
 */
package org.sqlproc.meta.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmEnumerationLiteral;
import org.eclipse.xtext.common.types.JvmEnumerationType;
import org.eclipse.xtext.common.types.JvmFeature;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmPrimitiveType;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.sqlproc.meta.processorMeta.Artifacts;
import org.sqlproc.meta.processorMeta.Column;
import org.sqlproc.meta.processorMeta.Constant;
import org.sqlproc.meta.processorMeta.DatabaseColumn;
import org.sqlproc.meta.processorMeta.DatabaseTable;
import org.sqlproc.meta.processorMeta.ExtendedColumn;
import org.sqlproc.meta.processorMeta.FunctionDefinitionModel;
import org.sqlproc.meta.processorMeta.Identifier;
import org.sqlproc.meta.processorMeta.IfSql;
import org.sqlproc.meta.processorMeta.IfSqlFragment;
import org.sqlproc.meta.processorMeta.MappingColumn;
import org.sqlproc.meta.processorMeta.MappingRule;
import org.sqlproc.meta.processorMeta.MetaSql;
import org.sqlproc.meta.processorMeta.MetaStatement;
import org.sqlproc.meta.processorMeta.OptionalFeature;
import org.sqlproc.meta.processorMeta.OrdSql;
import org.sqlproc.meta.processorMeta.PojoDefinitionModel;
import org.sqlproc.meta.processorMeta.ProcedureDefinitionModel;
import org.sqlproc.meta.processorMeta.ProcessorMetaPackage;
import org.sqlproc.meta.processorMeta.Property;
import org.sqlproc.meta.processorMeta.Sql;
import org.sqlproc.meta.processorMeta.SqlFragment;
import org.sqlproc.meta.processorMeta.TableDefinitionModel;
import org.sqlproc.meta.util.Utils;
import org.sqlproc.meta.validation.AbstractProcessorMetaValidator;
import org.sqlproc.meta.validation.ValidationResult;
import org.sqlproc.plugin.lib.property.ModelProperty;
import org.sqlproc.plugin.lib.property.PojoDefinition;
import org.sqlproc.plugin.lib.property.TableDefinition;
import org.sqlproc.plugin.lib.resolver.DbResolver;
import org.sqlproc.plugin.lib.resolver.PojoResolver;
import org.sqlproc.plugin.lib.resolver.PojoResolverFactory;
import org.sqlproc.plugin.lib.util.CommonUtils;
import org.sqlproc.plugin.lib.util.Constants;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class ProcessorMetaValidator extends AbstractProcessorMetaValidator {
  @Inject
  private PojoResolverFactory pojoResolverFactory;
  
  @Inject
  private DbResolver dbResolver;
  
  @Inject
  private ModelProperty modelProperty;
  
  private final HashSet<String> F_TYPES = CollectionLiterals.<String>newHashSet("set", "update", "values", "where", "columns", "set=opt", "where=opt");
  
  @Check
  public void checkMetaSqlFtype(final MetaSql metaSql) {
    String _ftype = metaSql.getFtype();
    boolean _equals = Objects.equal(_ftype, null);
    if (_equals) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(metaSql, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    boolean _and = false;
    String _ftype_1 = metaSql.getFtype();
    boolean _notEquals = (!Objects.equal(_ftype_1, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _ftype_2 = metaSql.getFtype();
      String _lowerCase = _ftype_2.toLowerCase();
      boolean _contains = this.F_TYPES.contains(_lowerCase);
      boolean _not = (!_contains);
      _and = _not;
    }
    if (_and) {
      String _ftype_3 = metaSql.getFtype();
      String _plus = ("Invalid ftype : " + _ftype_3);
      this.error(_plus, ProcessorMetaPackage.Literals.META_SQL__FTYPE);
    }
  }
  
  @Check
  public void checkUniqueMetaStatement(final MetaStatement metaStatement) {
    boolean _skipVerification = CommonUtils.skipVerification(metaStatement, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(metaStatement);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<MetaStatement> _statements = artifacts.getStatements();
    for (final MetaStatement metaStmt : _statements) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(metaStmt, null));
      if (!_notEquals) {
        _and = false;
      } else {
        _and = (metaStmt != metaStatement);
      }
      if (_and) {
        boolean _equalsStatement = this.equalsStatement(metaStatement, metaStmt);
        if (_equalsStatement) {
          String _name = metaStatement.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[");
          String _type = metaStatement.getType();
          String _plus_2 = (_plus_1 + _type);
          String _plus_3 = (_plus_2 + "]");
          this.error(_plus_3, 
            ProcessorMetaPackage.Literals.META_STATEMENT__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsStatement(final MetaStatement statement1, final MetaStatement statement2) {
    boolean _and = false;
    boolean _equals = Objects.equal(statement1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(statement2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _or = false;
    boolean _equals_2 = Objects.equal(statement1, null);
    if (_equals_2) {
      _or = true;
    } else {
      String _name = statement1.getName();
      boolean _equals_3 = Objects.equal(_name, null);
      _or = _equals_3;
    }
    if (_or) {
      return false;
    }
    boolean _or_1 = false;
    boolean _equals_4 = Objects.equal(statement2, null);
    if (_equals_4) {
      _or_1 = true;
    } else {
      String _name_1 = statement2.getName();
      boolean _equals_5 = Objects.equal(_name_1, null);
      _or_1 = _equals_5;
    }
    if (_or_1) {
      return false;
    }
    boolean _and_1 = false;
    String _name_2 = statement1.getName();
    String _name_3 = statement2.getName();
    boolean _equals_6 = _name_2.equals(_name_3);
    if (!_equals_6) {
      _and_1 = false;
    } else {
      String _type = statement1.getType();
      String _type_1 = statement2.getType();
      boolean _equals_7 = _type.equals(_type_1);
      _and_1 = _equals_7;
    }
    if (_and_1) {
      EList<String> _modifiers = statement1.getModifiers();
      EList<String> _modifiers_1 = statement2.getModifiers();
      return this.equalsModifiers(_modifiers, _modifiers_1);
    }
    return false;
  }
  
  @Check
  public void checkUniqueMappingRule(final MappingRule mappingRule) {
    boolean _skipVerification = CommonUtils.skipVerification(mappingRule, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(mappingRule);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<MappingRule> _mappings = artifacts.getMappings();
    for (final MappingRule rule : _mappings) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(rule, null));
      if (!_notEquals) {
        _and = false;
      } else {
        _and = (rule != mappingRule);
      }
      if (_and) {
        boolean _equalsRule = this.equalsRule(mappingRule, rule);
        if (_equalsRule) {
          String _name = mappingRule.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[");
          String _type = mappingRule.getType();
          String _plus_2 = (_plus_1 + _type);
          String _plus_3 = (_plus_2 + "]");
          this.error(_plus_3, 
            ProcessorMetaPackage.Literals.MAPPING_RULE__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsRule(final MappingRule rule1, final MappingRule rule2) {
    boolean _and = false;
    boolean _equals = Objects.equal(rule1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(rule2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _or = false;
    boolean _equals_2 = Objects.equal(rule1, null);
    if (_equals_2) {
      _or = true;
    } else {
      String _name = rule1.getName();
      boolean _equals_3 = Objects.equal(_name, null);
      _or = _equals_3;
    }
    if (_or) {
      return false;
    }
    boolean _or_1 = false;
    boolean _equals_4 = Objects.equal(rule2, null);
    if (_equals_4) {
      _or_1 = true;
    } else {
      String _name_1 = rule2.getName();
      boolean _equals_5 = Objects.equal(_name_1, null);
      _or_1 = _equals_5;
    }
    if (_or_1) {
      return false;
    }
    boolean _and_1 = false;
    String _name_2 = rule1.getName();
    String _name_3 = rule2.getName();
    boolean _equals_6 = _name_2.equals(_name_3);
    if (!_equals_6) {
      _and_1 = false;
    } else {
      String _type = rule1.getType();
      String _type_1 = rule2.getType();
      boolean _equals_7 = _type.equals(_type_1);
      _and_1 = _equals_7;
    }
    if (_and_1) {
      EList<String> _modifiers = rule1.getModifiers();
      EList<String> _modifiers_1 = rule2.getModifiers();
      return this.equalsModifiers(_modifiers, _modifiers_1);
    }
    return false;
  }
  
  @Check
  public void checkUniqueOptionalFeature(final OptionalFeature optionalFeature) {
    boolean _skipVerification = CommonUtils.skipVerification(optionalFeature, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(optionalFeature);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<OptionalFeature> _features = artifacts.getFeatures();
    for (final OptionalFeature feature : _features) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(feature, null));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _notEquals_1 = (!Objects.equal(feature, optionalFeature));
        _and = _notEquals_1;
      }
      if (_and) {
        boolean _equalsFeature = this.equalsFeature(optionalFeature, feature);
        if (_equalsFeature) {
          String _name = optionalFeature.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[");
          String _type = optionalFeature.getType();
          String _plus_2 = (_plus_1 + _type);
          String _plus_3 = (_plus_2 + "]");
          this.error(_plus_3, 
            ProcessorMetaPackage.Literals.OPTIONAL_FEATURE__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsFeature(final OptionalFeature feature1, final OptionalFeature feature2) {
    boolean _and = false;
    boolean _equals = Objects.equal(feature1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(feature2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _or = false;
    boolean _equals_2 = Objects.equal(feature1, null);
    if (_equals_2) {
      _or = true;
    } else {
      String _name = feature1.getName();
      boolean _equals_3 = Objects.equal(_name, null);
      _or = _equals_3;
    }
    if (_or) {
      return false;
    }
    boolean _or_1 = false;
    boolean _equals_4 = Objects.equal(feature2, null);
    if (_equals_4) {
      _or_1 = true;
    } else {
      String _name_1 = feature2.getName();
      boolean _equals_5 = Objects.equal(_name_1, null);
      _or_1 = _equals_5;
    }
    if (_or_1) {
      return false;
    }
    boolean _and_1 = false;
    String _name_2 = feature1.getName();
    String _name_3 = feature2.getName();
    boolean _equals_6 = _name_2.equals(_name_3);
    if (!_equals_6) {
      _and_1 = false;
    } else {
      String _type = feature1.getType();
      String _type_1 = feature2.getType();
      boolean _equals_7 = _type.equals(_type_1);
      _and_1 = _equals_7;
    }
    if (_and_1) {
      EList<String> _modifiers = feature1.getModifiers();
      EList<String> _modifiers_1 = feature2.getModifiers();
      return this.equalsModifiers(_modifiers, _modifiers_1);
    }
    return false;
  }
  
  @Check
  public void checkUniquePojoDefinition(final PojoDefinitionModel pojoDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(pojoDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(pojoDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<PojoDefinitionModel> _pojos = artifacts.getPojos();
    for (final PojoDefinitionModel definition : _pojos) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(definition, null));
      if (!_notEquals) {
        _and = false;
      } else {
        _and = (definition != pojoDefinition);
      }
      if (_and) {
        String _name = pojoDefinition.getName();
        String _name_1 = definition.getName();
        boolean _equals_1 = _name.equals(_name_1);
        if (_equals_1) {
          String _name_2 = pojoDefinition.getName();
          String _plus = ("Duplicate name : " + _name_2);
          this.error(_plus, 
            ProcessorMetaPackage.Literals.POJO_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
  }
  
  @Check
  public void checkUniqueProperty(final Property property) {
    boolean _skipVerification = CommonUtils.skipVerification(property, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(property);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<Property> _properties = artifacts.getProperties();
    for (final Property prop : _properties) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(prop, null));
      if (!_notEquals) {
        _and = false;
      } else {
        _and = (prop != property);
      }
      if (_and) {
        boolean _and_1 = false;
        boolean _and_2 = false;
        boolean _and_3 = false;
        boolean _and_4 = false;
        boolean _and_5 = false;
        String _name = prop.getName();
        String _name_1 = property.getName();
        boolean _equals_1 = _name.equals(_name_1);
        if (!_equals_1) {
          _and_5 = false;
        } else {
          String _name_2 = prop.getName();
          boolean _startsWith = _name_2.startsWith("pojogen");
          boolean _not = (!_startsWith);
          _and_5 = _not;
        }
        if (!_and_5) {
          _and_4 = false;
        } else {
          String _name_3 = prop.getName();
          boolean _startsWith_1 = _name_3.startsWith("database");
          boolean _not_1 = (!_startsWith_1);
          _and_4 = _not_1;
        }
        if (!_and_4) {
          _and_3 = false;
        } else {
          String _name_4 = prop.getName();
          boolean _startsWith_2 = _name_4.startsWith("metagen");
          boolean _not_2 = (!_startsWith_2);
          _and_3 = _not_2;
        }
        if (!_and_3) {
          _and_2 = false;
        } else {
          String _name_5 = prop.getName();
          boolean _startsWith_3 = _name_5.startsWith("daogen");
          boolean _not_3 = (!_startsWith_3);
          _and_2 = _not_3;
        }
        if (!_and_2) {
          _and_1 = false;
        } else {
          String _name_6 = prop.getName();
          boolean _startsWith_4 = _name_6.startsWith("replace-text");
          boolean _not_4 = (!_startsWith_4);
          _and_1 = _not_4;
        }
        if (_and_1) {
          String _name_7 = property.getName();
          String _plus = ("Duplicate name : " + _name_7);
          this.error(_plus, ProcessorMetaPackage.Literals.PROPERTY__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsModifiers(final List<String> modifiers1, final List<String> modifiers2) {
    final List<String> filteredModifiers1 = this.filteredModifiers(modifiers1);
    final List<String> filteredModifiers2 = this.filteredModifiers(modifiers2);
    boolean _and = false;
    boolean _equals = Objects.equal(filteredModifiers1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(filteredModifiers2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _equals_2 = Objects.equal(filteredModifiers1, null);
    if (_equals_2) {
      return false;
    }
    boolean _equals_3 = Objects.equal(filteredModifiers2, null);
    if (_equals_3) {
      return false;
    }
    boolean _and_1 = false;
    boolean _isEmpty = filteredModifiers1.isEmpty();
    if (!_isEmpty) {
      _and_1 = false;
    } else {
      boolean _isEmpty_1 = filteredModifiers2.isEmpty();
      _and_1 = _isEmpty_1;
    }
    if (_and_1) {
      return true;
    }
    for (final String modifier1 : filteredModifiers1) {
      for (final String modifier2 : filteredModifiers2) {
        boolean _equals_4 = modifier1.equals(modifier2);
        if (_equals_4) {
          return true;
        }
      }
    }
    return false;
  }
  
  public List<String> filteredModifiers(final List<String> modifiers) {
    boolean _equals = Objects.equal(modifiers, null);
    if (_equals) {
      return null;
    }
    final ArrayList<String> filteredModifiers = CollectionLiterals.<String>newArrayList();
    final Procedure1<String> _function = new Procedure1<String>() {
      @Override
      public void apply(final String modifier) {
        int _indexOf = modifier.indexOf("=");
        boolean _lessThan = (_indexOf < 0);
        if (_lessThan) {
          filteredModifiers.add(modifier);
        }
      }
    };
    IterableExtensions.<String>forEach(modifiers, _function);
    return filteredModifiers;
  }
  
  public String getClass(final PojoDefinitionModel pojo) {
    JvmType _classx = pojo.getClassx();
    boolean _notEquals = (!Objects.equal(_classx, null));
    if (_notEquals) {
      JvmType _classx_1 = pojo.getClassx();
      return _classx_1.getQualifiedName();
    }
    return pojo.getClass_();
  }
  
  @Check
  public void checkMetaStatement(final MetaStatement statement) {
    boolean _or = false;
    EList<String> _modifiers = statement.getModifiers();
    boolean _equals = Objects.equal(_modifiers, null);
    if (_equals) {
      _or = true;
    } else {
      EList<String> _modifiers_1 = statement.getModifiers();
      boolean _isEmpty = _modifiers_1.isEmpty();
      _or = _isEmpty;
    }
    if (_or) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(statement, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(statement);
    boolean _equals_1 = Objects.equal(artifacts, null);
    if (_equals_1) {
      return;
    }
    Resource _eResource = statement.eResource();
    URI _uRI = null;
    if (_eResource!=null) {
      _uRI=_eResource.getURI();
    }
    final URI uri = _uRI;
    final Map<String, PropertyDescriptor[]> descriptorsCache = new HashMap<String, PropertyDescriptor[]>();
    final Map<String, Class<?>> classesCache = new HashMap<String, Class<?>>();
    final Map<String, Map<String, String>> ordersCache = new HashMap<String, Map<String, String>>();
    int index = 0;
    String identPojoName = null;
    PojoDefinition identPojo = null;
    String indexPojoName = null;
    PojoDefinition indexPojo = null;
    String colPojoName = null;
    PojoDefinition colPojo = null;
    String constPojoName = null;
    PojoDefinition constPojo = null;
    final TreeMap<String, TableDefinition> tablesPojo = new TreeMap<String, TableDefinition>();
    final TreeMap<String, TableDefinition> tablesPrefixPojo = new TreeMap<String, TableDefinition>();
    EList<String> _modifiers_2 = statement.getModifiers();
    for (final String modifier : _modifiers_2) {
      {
        final String[] values = modifier.split("=");
        int _length = values.length;
        boolean _greaterThan = (_length > 1);
        if (_greaterThan) {
          final String key = values[0];
          final String value = values[1];
          boolean _equals_2 = Constants.IDENTIFIER_USAGE.equals(key);
          if (_equals_2) {
            Map<String, PojoDefinition> _modelPojos = this.modelProperty.getModelPojos(artifacts);
            PojoDefinition _get = _modelPojos.get(value);
            identPojo = _get;
            boolean _equals_3 = Objects.equal(identPojo, null);
            if (_equals_3) {
              this.error((((("Cannot find pojo : " + value) + "[") + Constants.IDENTIFIER_USAGE) + "]"), 
                ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
            } else {
              identPojoName = value;
            }
          }
          boolean _equals_4 = Constants.INDEX_USAGE.equals(key);
          if (_equals_4) {
            Map<String, PojoDefinition> _modelPojos_1 = this.modelProperty.getModelPojos(artifacts);
            PojoDefinition _get_1 = _modelPojos_1.get(value);
            indexPojo = _get_1;
            boolean _equals_5 = Objects.equal(indexPojo, null);
            if (_equals_5) {
              this.error((((("Cannot find pojo : " + value) + "[") + Constants.INDEX_USAGE) + "]"), 
                ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
            } else {
              indexPojoName = value;
            }
          } else {
            boolean _equals_6 = Constants.COLUMN_USAGE.equals(key);
            if (_equals_6) {
              Map<String, PojoDefinition> _modelPojos_2 = this.modelProperty.getModelPojos(artifacts);
              PojoDefinition _get_2 = _modelPojos_2.get(value);
              colPojo = _get_2;
              boolean _equals_7 = Objects.equal(colPojo, null);
              if (_equals_7) {
                this.error((((("Cannot find pojo : " + value) + "[") + Constants.COLUMN_USAGE) + "]"), 
                  ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
              } else {
                colPojoName = value;
              }
            } else {
              boolean _equals_8 = Constants.CONSTANT_USAGE.equals(key);
              if (_equals_8) {
                Map<String, PojoDefinition> _modelPojos_3 = this.modelProperty.getModelPojos(artifacts);
                PojoDefinition _get_3 = _modelPojos_3.get(value);
                constPojo = _get_3;
                boolean _equals_9 = Objects.equal(constPojo, null);
                if (_equals_9) {
                  this.error((((("Cannot find pojo : " + value) + "[") + Constants.CONSTANT_USAGE) + "]"), 
                    ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
                } else {
                  constPojoName = value;
                }
              } else {
                boolean _equals_10 = Constants.TABLE_USAGE.equals(key);
                if (_equals_10) {
                  String _xifexpression = null;
                  int _length_1 = values.length;
                  boolean _greaterThan_1 = (_length_1 > 2);
                  if (_greaterThan_1) {
                    _xifexpression = values[2];
                  } else {
                    _xifexpression = "_DEFAULT_";
                  }
                  final String prefix = _xifexpression;
                  Map<String, TableDefinition> _modelTables = this.modelProperty.getModelTables(artifacts);
                  final TableDefinition table = _modelTables.get(value);
                  boolean _equals_11 = Objects.equal(table, null);
                  if (_equals_11) {
                    this.error((((("Cannot find table : " + value) + "[") + Constants.TABLE_USAGE) + "]"), 
                      ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
                  } else {
                    tablesPojo.put(value, table);
                    tablesPrefixPojo.put(prefix, table);
                  }
                }
              }
            }
          }
          index = (index + 1);
        }
      }
    }
    boolean _equals_2 = Objects.equal(indexPojo, null);
    if (_equals_2) {
      indexPojo = identPojo;
      indexPojoName = identPojoName;
    }
    boolean _isOldPojoValidator = this.modelProperty.isOldPojoValidator(statement);
    final boolean newPojoValidator = (!_isOldPojoValidator);
    boolean _notEquals = (!Objects.equal(identPojo, null));
    if (_notEquals) {
      final List<Identifier> identifiers = EcoreUtil2.<Identifier>getAllContentsOfType(statement, Identifier.class);
      final PojoDefinition pojo = identPojo;
      final String pojoName = identPojoName;
      final Procedure1<Identifier> _function = new Procedure1<Identifier>() {
        @Override
        public void apply(final Identifier identifier) {
          ProcessorMetaValidator.this.checkIdentifier(identifier, pojo, pojoName, statement, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
        }
      };
      IterableExtensions.<Identifier>forEach(identifiers, _function);
    }
    boolean _notEquals_1 = (!Objects.equal(indexPojo, null));
    if (_notEquals_1) {
      final List<OrdSql> orders = EcoreUtil2.<OrdSql>getAllContentsOfType(statement, OrdSql.class);
      final PojoDefinition pojo_1 = indexPojo;
      final String pojoName_1 = indexPojoName;
      final Procedure1<OrdSql> _function_1 = new Procedure1<OrdSql>() {
        @Override
        public void apply(final OrdSql order) {
          ProcessorMetaValidator.this.checkOrder(order, pojo_1, pojoName_1, statement, newPojoValidator, artifacts, uri, ordersCache, classesCache);
        }
      };
      IterableExtensions.<OrdSql>forEach(orders, _function_1);
    }
    boolean _notEquals_2 = (!Objects.equal(colPojo, null));
    if (_notEquals_2) {
      final List<Column> columns = EcoreUtil2.<Column>getAllContentsOfType(statement, Column.class);
      final PojoDefinition pojo_2 = colPojo;
      final String pojoName_2 = colPojoName;
      final Procedure1<Column> _function_2 = new Procedure1<Column>() {
        @Override
        public void apply(final Column column) {
          ProcessorMetaValidator.this.checkColumn(column, pojo_2, pojoName_2, statement, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
        }
      };
      IterableExtensions.<Column>forEach(columns, _function_2);
    }
    boolean _notEquals_3 = (!Objects.equal(constPojo, null));
    if (_notEquals_3) {
      final List<Constant> constants = EcoreUtil2.<Constant>getAllContentsOfType(statement, Constant.class);
      final PojoDefinition pojo_3 = constPojo;
      final String pojoName_3 = constPojoName;
      final Procedure1<Constant> _function_3 = new Procedure1<Constant>() {
        @Override
        public void apply(final Constant constant) {
          ProcessorMetaValidator.this.checkConstant(constant, pojo_3, pojoName_3, statement, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
        }
      };
      IterableExtensions.<Constant>forEach(constants, _function_3);
    }
    boolean _isResolveDb = this.isResolveDb(statement);
    if (_isResolveDb) {
      this.checkTablesColumns(tablesPojo, tablesPrefixPojo, statement);
    }
  }
  
  public void checkTablesColumns(final TreeMap<String, TableDefinition> tablesPojo, final TreeMap<String, TableDefinition> tablesPrefixPojo, final MetaStatement statement) {
    final List<DatabaseTable> tables = EcoreUtil2.<DatabaseTable>getAllContentsOfType(statement, DatabaseTable.class);
    final Procedure1<DatabaseTable> _function = new Procedure1<DatabaseTable>() {
      @Override
      public void apply(final DatabaseTable table) {
        final String tableName = table.getName();
        Collection<TableDefinition> _values = tablesPojo.values();
        final Function1<TableDefinition, Boolean> _function = new Function1<TableDefinition, Boolean>() {
          @Override
          public Boolean apply(final TableDefinition it) {
            String _table = it.getTable();
            return Boolean.valueOf(Objects.equal(_table, tableName));
          }
        };
        final TableDefinition tableDefinition = IterableExtensions.<TableDefinition>findFirst(_values, _function);
        boolean _or = false;
        boolean _equals = Objects.equal(tableDefinition, null);
        if (_equals) {
          _or = true;
        } else {
          boolean _checkTable = ProcessorMetaValidator.this.dbResolver.checkTable(statement, tableName);
          boolean _not = (!_checkTable);
          _or = _not;
        }
        if (_or) {
          ProcessorMetaValidator.this.error(("Cannot find table in DB : " + tableName), table, ProcessorMetaPackage.Literals.DATABASE_TABLE__NAME);
        }
      }
    };
    IterableExtensions.<DatabaseTable>forEach(tables, _function);
    final List<DatabaseColumn> columns = EcoreUtil2.<DatabaseColumn>getAllContentsOfType(statement, DatabaseColumn.class);
    final Procedure1<DatabaseColumn> _function_1 = new Procedure1<DatabaseColumn>() {
      @Override
      public void apply(final DatabaseColumn column) {
        String _name = column.getName();
        final int pos = _name.indexOf(".");
        String _xifexpression = null;
        if ((pos > 0)) {
          String _name_1 = column.getName();
          _xifexpression = _name_1.substring(0, pos);
        } else {
          _xifexpression = "_DEFAULT_";
        }
        final String prefix = _xifexpression;
        String _xifexpression_1 = null;
        if ((pos > 0)) {
          String _name_2 = column.getName();
          _xifexpression_1 = _name_2.substring((pos + 1));
        } else {
          _xifexpression_1 = column.getName();
        }
        final String columnName = _xifexpression_1;
        final TableDefinition tableDefinition = tablesPrefixPojo.get(prefix);
        String _xifexpression_2 = null;
        boolean _notEquals = (!Objects.equal(tableDefinition, null));
        if (_notEquals) {
          _xifexpression_2 = tableDefinition.getTable();
        }
        final String tableName = _xifexpression_2;
        boolean _or = false;
        boolean _equals = Objects.equal(tableName, null);
        if (_equals) {
          _or = true;
        } else {
          boolean _checkColumn = ProcessorMetaValidator.this.dbResolver.checkColumn(column, tableName, columnName);
          boolean _not = (!_checkColumn);
          _or = _not;
        }
        if (_or) {
          String _name_3 = column.getName();
          String _plus = ("Cannot find column in DB : " + _name_3);
          String _plus_1 = (_plus + "[");
          String _plus_2 = (_plus_1 + tableName);
          String _plus_3 = (_plus_2 + "]");
          ProcessorMetaValidator.this.error(_plus_3, column, ProcessorMetaPackage.Literals.DATABASE_COLUMN__NAME);
        }
      }
    };
    IterableExtensions.<DatabaseColumn>forEach(columns, _function_1);
  }
  
  public void checkIdentifier(final Identifier identifier, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(identifier);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String identifierName = identifier.getName();
    final String identifierUsageClass = pojo.getQualifiedName();
    ValidationResult validationResult = null;
    boolean _notEquals = (!Objects.equal(identifierUsageClass, null));
    if (_notEquals) {
      boolean _and = false;
      if (!newPojoValidator) {
        _and = false;
      } else {
        JvmType _classx = pojo.getClassx();
        _and = (_classx instanceof JvmDeclaredType);
      }
      if (_and) {
        JvmType _classx_1 = pojo.getClassx();
        ValidationResult _checkClassProperty = this.checkClassProperty(((JvmDeclaredType) _classx_1), identifierName);
        validationResult = _checkClassProperty;
      } else {
        ValidationResult _checkClassProperty_1 = this.checkClassProperty(identifierUsageClass, identifierName, uri, descriptorsCache, classesCache);
        validationResult = _checkClassProperty_1;
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem property : " + identifierName) + "[") + identifierUsageClass) + "]"), identifier, ProcessorMetaPackage.Literals.IDENTIFIER__NAME);
            break;
          case ERROR:
            this.error((((("Cannot find property : " + identifierName) + "[") + identifierUsageClass) + "]"), identifier, ProcessorMetaPackage.Literals.IDENTIFIER__NAME);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_1 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_1) {
      this.error(("Cannot check input form attribute : " + identifierName), identifier, ProcessorMetaPackage.Literals.IDENTIFIER__NAME);
    }
  }
  
  public void checkOrder(final OrdSql order, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, Map<String, String>> ordersCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(order);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String identifierName = order.getIdent();
    final String identifierUsageClass = pojo.getQualifiedName();
    ValidationResult validationResult = null;
    boolean _notEquals = (!Objects.equal(identifierUsageClass, null));
    if (_notEquals) {
      boolean _and = false;
      if (!newPojoValidator) {
        _and = false;
      } else {
        JvmType _classx = pojo.getClassx();
        _and = (_classx instanceof JvmDeclaredType);
      }
      if (_and) {
        JvmType _classx_1 = pojo.getClassx();
        ValidationResult _checkOrderProperty = this.checkOrderProperty(((JvmDeclaredType) _classx_1), identifierName);
        validationResult = _checkOrderProperty;
      } else {
        this.checkOrderProperty(identifierUsageClass, identifierName, uri, ordersCache, classesCache);
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem order : " + identifierName) + "[") + identifierUsageClass) + "]"), order, ProcessorMetaPackage.Literals.ORD_SQL__IDENT);
            break;
          case ERROR:
            this.warning((((("Cannot find order : " + identifierName) + "[") + identifierUsageClass) + "]"), order, ProcessorMetaPackage.Literals.ORD_SQL__IDENT);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_1 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_1) {
      this.error(("Cannot check order identifier : " + identifierName), order, ProcessorMetaPackage.Literals.ORD_SQL__IDENT);
    }
  }
  
  public void checkColumn(final Column column, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(column);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String columnName = Utils.getName(column);
    boolean _isNumber = Utils.isNumber(columnName);
    if (_isNumber) {
      return;
    }
    String _xifexpression = null;
    boolean _notEquals = (!Objects.equal(pojo, null));
    if (_notEquals) {
      _xifexpression = pojo.getQualifiedName();
    }
    final String columnUsageClass = _xifexpression;
    ValidationResult validationResult = null;
    boolean _notEquals_1 = (!Objects.equal(columnUsageClass, null));
    if (_notEquals_1) {
      boolean _and = false;
      if (!newPojoValidator) {
        _and = false;
      } else {
        JvmType _classx = pojo.getClassx();
        _and = (_classx instanceof JvmDeclaredType);
      }
      if (_and) {
        JvmType _classx_1 = pojo.getClassx();
        ValidationResult _checkClassProperty = this.checkClassProperty(((JvmDeclaredType) _classx_1), columnName);
        validationResult = _checkClassProperty;
      } else {
        ValidationResult _checkClassProperty_1 = this.checkClassProperty(columnUsageClass, columnName, uri, descriptorsCache, classesCache);
        validationResult = _checkClassProperty_1;
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
            break;
          case ERROR:
            this.checkColumnGType(column, columnName, columnUsageClass, statement);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_2 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_2) {
      this.error(("Cannot check result class attribute : " + columnName), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
    }
  }
  
  public void checkColumnGType(final Column column, final String columnName, final String columnUsageClass, final MetaStatement statement) {
    boolean _or = false;
    Sql _statement = statement.getStatement();
    boolean _equals = Objects.equal(_statement, null);
    if (_equals) {
      _or = true;
    } else {
      Sql _statement_1 = statement.getStatement();
      EList<SqlFragment> _sqls = _statement_1.getSqls();
      boolean _equals_1 = Objects.equal(_sqls, null);
      _or = _equals_1;
    }
    if (_or) {
      return;
    }
    Sql _statement_2 = statement.getStatement();
    EList<SqlFragment> _sqls_1 = _statement_2.getSqls();
    for (final SqlFragment stmt : _sqls_1) {
      {
        boolean _and = false;
        boolean _and_1 = false;
        Column _col = stmt.getCol();
        boolean _notEquals = (!Objects.equal(_col, null));
        if (!_notEquals) {
          _and_1 = false;
        } else {
          Column _col_1 = stmt.getCol();
          EList<ExtendedColumn> _columns = _col_1.getColumns();
          boolean _notEquals_1 = (!Objects.equal(_columns, null));
          _and_1 = _notEquals_1;
        }
        if (!_and_1) {
          _and = false;
        } else {
          Column _col_2 = stmt.getCol();
          EList<ExtendedColumn> _columns_1 = _col_2.getColumns();
          boolean _notEquals_2 = (!Objects.equal(_columns_1, null));
          _and = _notEquals_2;
        }
        if (_and) {
          Column _col_3 = stmt.getCol();
          EList<ExtendedColumn> _columns_2 = _col_3.getColumns();
          for (final ExtendedColumn _col_4 : _columns_2) {
            EList<String> _modifiers = _col_4.getModifiers();
            boolean _notEquals_3 = (!Objects.equal(_modifiers, null));
            if (_notEquals_3) {
              EList<String> _modifiers_1 = _col_4.getModifiers();
              for (final String mod : _modifiers_1) {
                int _indexOf = mod.indexOf("gtype");
                boolean _greaterEqualsThan = (_indexOf >= 0);
                if (_greaterEqualsThan) {
                  this.warning((((("Problem property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
                  return;
                }
              }
            }
          }
        }
        boolean _and_2 = false;
        MetaSql _meta = stmt.getMeta();
        boolean _notEquals_4 = (!Objects.equal(_meta, null));
        if (!_notEquals_4) {
          _and_2 = false;
        } else {
          MetaSql _meta_1 = stmt.getMeta();
          EList<IfSql> _ifs = _meta_1.getIfs();
          boolean _notEquals_5 = (!Objects.equal(_ifs, null));
          _and_2 = _notEquals_5;
        }
        if (_and_2) {
          MetaSql _meta_2 = stmt.getMeta();
          EList<IfSql> _ifs_1 = _meta_2.getIfs();
          for (final IfSql ifs : _ifs_1) {
            EList<IfSqlFragment> _sqls_2 = ifs.getSqls();
            boolean _notEquals_6 = (!Objects.equal(_sqls_2, null));
            if (_notEquals_6) {
              EList<IfSqlFragment> _sqls_3 = ifs.getSqls();
              for (final IfSqlFragment stmt2 : _sqls_3) {
                boolean _and_3 = false;
                boolean _and_4 = false;
                Column _col_5 = stmt2.getCol();
                boolean _notEquals_7 = (!Objects.equal(_col_5, null));
                if (!_notEquals_7) {
                  _and_4 = false;
                } else {
                  Column _col_6 = stmt2.getCol();
                  EList<ExtendedColumn> _columns_3 = _col_6.getColumns();
                  boolean _notEquals_8 = (!Objects.equal(_columns_3, null));
                  _and_4 = _notEquals_8;
                }
                if (!_and_4) {
                  _and_3 = false;
                } else {
                  Column _col_7 = stmt2.getCol();
                  EList<ExtendedColumn> _columns_4 = _col_7.getColumns();
                  boolean _notEquals_9 = (!Objects.equal(_columns_4, null));
                  _and_3 = _notEquals_9;
                }
                if (_and_3) {
                  Column _col_8 = stmt2.getCol();
                  EList<ExtendedColumn> _columns_5 = _col_8.getColumns();
                  for (final ExtendedColumn _col_9 : _columns_5) {
                    EList<String> _modifiers_2 = _col_9.getModifiers();
                    boolean _notEquals_10 = (!Objects.equal(_modifiers_2, null));
                    if (_notEquals_10) {
                      EList<String> _modifiers_3 = _col_9.getModifiers();
                      for (final String mod_1 : _modifiers_3) {
                        int _indexOf_1 = mod_1.indexOf("gtype");
                        boolean _greaterEqualsThan_1 = (_indexOf_1 >= 0);
                        if (_greaterEqualsThan_1) {
                          this.warning((((("Problem property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
                          return;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    this.error((((("Cannot find property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
  }
  
  public void checkConstant(final Constant constant, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(constant);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    String _xifexpression = null;
    boolean _notEquals = (!Objects.equal(pojo, null));
    if (_notEquals) {
      _xifexpression = pojo.getQualifiedName();
    }
    final String constantUsageClass = _xifexpression;
    ValidationResult validationResult = null;
    boolean _notEquals_1 = (!Objects.equal(constantUsageClass, null));
    if (_notEquals_1) {
      boolean _and = false;
      if (!newPojoValidator) {
        _and = false;
      } else {
        JvmType _classx = pojo.getClassx();
        _and = (_classx instanceof JvmDeclaredType);
      }
      if (_and) {
        JvmType _classx_1 = pojo.getClassx();
        String _name = constant.getName();
        ValidationResult _checkClassProperty = this.checkClassProperty(((JvmDeclaredType) _classx_1), _name);
        validationResult = _checkClassProperty;
      } else {
        String _name_1 = constant.getName();
        ValidationResult _checkClassProperty_1 = this.checkClassProperty(constantUsageClass, _name_1, uri, descriptorsCache, classesCache);
        validationResult = _checkClassProperty_1;
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            String _name_2 = constant.getName();
            String _plus = ("Problem property : " + _name_2);
            String _plus_1 = (_plus + "[");
            String _plus_2 = (_plus_1 + constantUsageClass);
            String _plus_3 = (_plus_2 + "]");
            this.warning(_plus_3, constant, ProcessorMetaPackage.Literals.CONSTANT__NAME);
            break;
          case ERROR:
            String _name_3 = constant.getName();
            String _plus_4 = ("Cannot find property : " + _name_3);
            String _plus_5 = (_plus_4 + "[");
            String _plus_6 = (_plus_5 + constantUsageClass);
            String _plus_7 = (_plus_6 + "]");
            this.error(_plus_7, constant, ProcessorMetaPackage.Literals.CONSTANT__NAME);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_2 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_2) {
      String _name_4 = constant.getName();
      String _plus_8 = ("Cannot check constant form attribute : " + _name_4);
      this.error(_plus_8, 
        ProcessorMetaPackage.Literals.CONSTANT__NAME);
    }
  }
  
  @Check
  public void checkMappingRule(final MappingRule rule) {
    boolean _or = false;
    EList<String> _modifiers = rule.getModifiers();
    boolean _equals = Objects.equal(_modifiers, null);
    if (_equals) {
      _or = true;
    } else {
      EList<String> _modifiers_1 = rule.getModifiers();
      boolean _isEmpty = _modifiers_1.isEmpty();
      _or = _isEmpty;
    }
    if (_or) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(rule, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(rule);
    boolean _equals_1 = Objects.equal(artifacts, null);
    if (_equals_1) {
      return;
    }
    Resource _eResource = rule.eResource();
    URI _uRI = null;
    if (_eResource!=null) {
      _uRI=_eResource.getURI();
    }
    final URI uri = _uRI;
    final Map<String, PropertyDescriptor[]> descriptorsCache = new HashMap<String, PropertyDescriptor[]>();
    final Map<String, Class<?>> classesCache = new HashMap<String, Class<?>>();
    int index = 0;
    String colPojoName = null;
    PojoDefinition colPojo = null;
    EList<String> _modifiers_2 = rule.getModifiers();
    for (final String modifier : _modifiers_2) {
      {
        int ix = modifier.indexOf("=");
        if ((ix > 0)) {
          final String key = modifier.substring(0, ix);
          final String value = modifier.substring((ix + 1));
          boolean _equals_2 = Constants.MAPPING_USAGE.equals(key);
          if (_equals_2) {
            Map<String, PojoDefinition> _modelPojos = this.modelProperty.getModelPojos(artifacts);
            PojoDefinition _get = _modelPojos.get(value);
            colPojo = _get;
            boolean _equals_3 = Objects.equal(colPojo, null);
            if (_equals_3) {
              this.error((((("Cannot find pojo : " + value) + "[") + Constants.MAPPING_USAGE) + "]"), 
                ProcessorMetaPackage.Literals.MAPPING_RULE__MODIFIERS, index);
            } else {
              colPojoName = value;
            }
          }
          index = (index + 1);
        }
      }
    }
    boolean _notEquals = (!Objects.equal(colPojo, null));
    if (_notEquals) {
      boolean _isOldPojoValidator = this.modelProperty.isOldPojoValidator(rule);
      final boolean newPojoValidator = (!_isOldPojoValidator);
      final List<MappingColumn> columns = EcoreUtil2.<MappingColumn>getAllContentsOfType(rule, MappingColumn.class);
      final PojoDefinition pojo = colPojo;
      final String pojoName = colPojoName;
      final Procedure1<MappingColumn> _function = new Procedure1<MappingColumn>() {
        @Override
        public void apply(final MappingColumn column) {
          ProcessorMetaValidator.this.checkMappingColumn(column, pojo, pojoName, rule, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
        }
      };
      IterableExtensions.<MappingColumn>forEach(columns, _function);
    }
  }
  
  public void checkMappingColumn(final MappingColumn column, final PojoDefinition pojo, final String pojoName, final MappingRule rule, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(column);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String columnName = Utils.getName(column);
    boolean _isNumber = Utils.isNumber(columnName);
    if (_isNumber) {
      return;
    }
    final String mappingUsageClass = pojo.getQualifiedName();
    ValidationResult validationResult = null;
    boolean _notEquals = (!Objects.equal(mappingUsageClass, null));
    if (_notEquals) {
      boolean _and = false;
      if (!newPojoValidator) {
        _and = false;
      } else {
        JvmType _classx = pojo.getClassx();
        _and = (_classx instanceof JvmDeclaredType);
      }
      if (_and) {
        JvmType _classx_1 = pojo.getClassx();
        ValidationResult _checkClassProperty = this.checkClassProperty(((JvmDeclaredType) _classx_1), columnName);
        validationResult = _checkClassProperty;
      } else {
        ValidationResult _checkClassProperty_1 = this.checkClassProperty(mappingUsageClass, columnName, uri, descriptorsCache, classesCache);
        validationResult = _checkClassProperty_1;
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem property : " + columnName) + "[") + mappingUsageClass) + "]"), column, ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS);
            break;
          case ERROR:
            this.error((((("Cannot find property : " + columnName) + "[") + mappingUsageClass) + "]"), column, ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_1 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_1) {
      this.error(("Cannot check result class attribute : " + columnName), column, ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS);
    }
  }
  
  public ValidationResult checkClassProperty(final String className, final String property, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _or = false;
    boolean _or_1 = false;
    boolean _equals = Objects.equal(property, null);
    if (_equals) {
      _or_1 = true;
    } else {
      boolean _isNumber = Utils.isNumber(property);
      _or_1 = _isNumber;
    }
    if (_or_1) {
      _or = true;
    } else {
      PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
      boolean _equals_1 = Objects.equal(_pojoResolver, null);
      _or = _equals_1;
    }
    if (_or) {
      return ValidationResult.OK;
    }
    boolean _equals_2 = Objects.equal(className, null);
    if (_equals_2) {
      return ValidationResult.ERROR;
    }
    String _string = uri.toString();
    String _plus = (_string + className);
    PropertyDescriptor[] descriptors = descriptorsCache.get(_plus);
    boolean _equals_3 = Objects.equal(descriptors, null);
    if (_equals_3) {
      PojoResolver _pojoResolver_1 = this.pojoResolverFactory.getPojoResolver();
      PropertyDescriptor[] _propertyDescriptors = _pojoResolver_1.getPropertyDescriptors(className, uri);
      descriptors = _propertyDescriptors;
    }
    boolean _equals_4 = Objects.equal(descriptors, null);
    if (_equals_4) {
      return ValidationResult.WARNING;
    } else {
      String _string_1 = uri.toString();
      String _plus_1 = (_string_1 + className);
      descriptorsCache.put(_plus_1, descriptors);
    }
    String checkProperty = property;
    int pos1 = checkProperty.indexOf("=");
    if ((pos1 > 0)) {
      int pos2 = checkProperty.indexOf(".", pos1);
      if ((pos2 > pos1)) {
        String _substring = checkProperty.substring(0, pos1);
        String _substring_1 = checkProperty.substring(pos2);
        String _plus_2 = (_substring + _substring_1);
        checkProperty = _plus_2;
      }
    }
    String innerProperty = ((String) null);
    int _indexOf = checkProperty.indexOf(".");
    pos1 = _indexOf;
    if ((pos1 > 0)) {
      String _substring_2 = checkProperty.substring((pos1 + 1));
      innerProperty = _substring_2;
      String _substring_3 = checkProperty.substring(0, pos1);
      checkProperty = _substring_3;
    }
    final String _checkProperty = checkProperty;
    final PropertyDescriptor[] _converted_descriptors = (PropertyDescriptor[])descriptors;
    final Function1<PropertyDescriptor, Boolean> _function = new Function1<PropertyDescriptor, Boolean>() {
      @Override
      public Boolean apply(final PropertyDescriptor descriptor) {
        String _name = descriptor.getName();
        return Boolean.valueOf(Objects.equal(_name, _checkProperty));
      }
    };
    PropertyDescriptor checkDesriptor = IterableExtensions.<PropertyDescriptor>findFirst(((Iterable<PropertyDescriptor>)Conversions.doWrapArray(_converted_descriptors)), _function);
    boolean _equals_5 = Objects.equal(checkDesriptor, null);
    if (_equals_5) {
      String _string_2 = uri.toString();
      String _plus_3 = (_string_2 + className);
      Class<?> clazz = classesCache.get(_plus_3);
      boolean _equals_6 = Objects.equal(clazz, null);
      if (_equals_6) {
        PojoResolver _pojoResolver_2 = this.pojoResolverFactory.getPojoResolver();
        Class<?> _loadClass = _pojoResolver_2.loadClass(className, uri);
        clazz = _loadClass;
      }
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(clazz, null));
      if (!_notEquals) {
        _and = false;
      } else {
        int _modifiers = clazz.getModifiers();
        boolean _isAbstract = Modifier.isAbstract(_modifiers);
        _and = _isAbstract;
      }
      if (_and) {
        return ValidationResult.WARNING;
      }
      boolean _and_1 = false;
      boolean _notEquals_1 = (!Objects.equal(clazz, null));
      if (!_notEquals_1) {
        _and_1 = false;
      } else {
        boolean _isPrimitive = this.isPrimitive(clazz);
        _and_1 = _isPrimitive;
      }
      if (_and_1) {
        return ValidationResult.OK;
      }
      return ValidationResult.ERROR;
    }
    boolean _notEquals_2 = (!Objects.equal(innerProperty, null));
    if (_notEquals_2) {
      Class<?> innerClass = checkDesriptor.getPropertyType();
      boolean _isArray = innerClass.isArray();
      if (_isArray) {
        Method _readMethod = checkDesriptor.getReadMethod();
        Type _genericReturnType = _readMethod.getGenericReturnType();
        final ParameterizedType type = ((ParameterizedType) _genericReturnType);
        boolean _or_2 = false;
        Type[] _actualTypeArguments = type.getActualTypeArguments();
        boolean _equals_7 = Objects.equal(_actualTypeArguments, null);
        if (_equals_7) {
          _or_2 = true;
        } else {
          Type[] _actualTypeArguments_1 = type.getActualTypeArguments();
          int _length = _actualTypeArguments_1.length;
          boolean _equals_8 = (_length == 0);
          _or_2 = _equals_8;
        }
        if (_or_2) {
          return ValidationResult.WARNING;
        }
        Type[] _actualTypeArguments_2 = type.getActualTypeArguments();
        Type _head = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(_actualTypeArguments_2)));
        innerClass = ((Class<?>) _head);
        boolean _isPrimitive_1 = this.isPrimitive(innerClass);
        if (_isPrimitive_1) {
          return ValidationResult.ERROR;
        }
        String _name = innerClass.getName();
        return this.checkClassProperty(_name, innerProperty, uri, descriptorsCache, classesCache);
      } else {
        boolean _isAssignableFrom = Collection.class.isAssignableFrom(innerClass);
        if (_isAssignableFrom) {
          Method _readMethod_1 = checkDesriptor.getReadMethod();
          Type _genericReturnType_1 = _readMethod_1.getGenericReturnType();
          final ParameterizedType type_1 = ((ParameterizedType) _genericReturnType_1);
          boolean _or_3 = false;
          Type[] _actualTypeArguments_3 = type_1.getActualTypeArguments();
          boolean _equals_9 = Objects.equal(_actualTypeArguments_3, null);
          if (_equals_9) {
            _or_3 = true;
          } else {
            Type[] _actualTypeArguments_4 = type_1.getActualTypeArguments();
            int _length_1 = _actualTypeArguments_4.length;
            boolean _equals_10 = (_length_1 == 0);
            _or_3 = _equals_10;
          }
          if (_or_3) {
            return ValidationResult.WARNING;
          }
          Type[] _actualTypeArguments_5 = type_1.getActualTypeArguments();
          Type _head_1 = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(_actualTypeArguments_5)));
          innerClass = ((Class<?>) _head_1);
          boolean _isPrimitive_2 = this.isPrimitive(innerClass);
          if (_isPrimitive_2) {
            return ValidationResult.ERROR;
          }
          String _name_1 = innerClass.getName();
          return this.checkClassProperty(_name_1, innerProperty, uri, descriptorsCache, classesCache);
        } else {
          boolean _isPrimitive_3 = this.isPrimitive(innerClass);
          if (_isPrimitive_3) {
            return ValidationResult.ERROR;
          }
          String _name_2 = innerClass.getName();
          return this.checkClassProperty(_name_2, innerProperty, uri, descriptorsCache, classesCache);
        }
      }
    }
    return ValidationResult.OK;
  }
  
  public ValidationResult checkClassProperty(final JvmDeclaredType jvmType, final String property) {
    boolean _or = false;
    boolean _equals = Objects.equal(property, null);
    if (_equals) {
      _or = true;
    } else {
      boolean _isNumber = Utils.isNumber(property);
      _or = _isNumber;
    }
    if (_or) {
      return ValidationResult.OK;
    }
    boolean _equals_1 = Objects.equal(jvmType, null);
    if (_equals_1) {
      return ValidationResult.ERROR;
    }
    String checkProperty = property;
    int pos1 = checkProperty.indexOf("=");
    if ((pos1 > 0)) {
      int pos2 = checkProperty.indexOf(".", pos1);
      if ((pos2 > pos1)) {
        String _substring = checkProperty.substring(0, pos1);
        String _substring_1 = checkProperty.substring(pos2);
        String _plus = (_substring + _substring_1);
        checkProperty = _plus;
      }
    }
    String innerProperty = ((String) null);
    int _indexOf = checkProperty.indexOf(".");
    pos1 = _indexOf;
    if ((pos1 > 0)) {
      String _substring_2 = checkProperty.substring((pos1 + 1));
      innerProperty = _substring_2;
      String _substring_3 = checkProperty.substring(0, pos1);
      checkProperty = _substring_3;
    }
    Iterable<JvmFeature> features = jvmType.findAllFeaturesByName(checkProperty);
    boolean _or_1 = false;
    boolean _or_2 = false;
    boolean _equals_2 = Objects.equal(features, null);
    if (_equals_2) {
      _or_2 = true;
    } else {
      boolean _isEmpty = IterableExtensions.isEmpty(features);
      _or_2 = _isEmpty;
    }
    if (_or_2) {
      _or_1 = true;
    } else {
      JvmFeature _head = IterableExtensions.<JvmFeature>head(features);
      boolean _not = (!(_head instanceof JvmField));
      _or_1 = _not;
    }
    if (_or_1) {
      String _firstUpper = StringExtensions.toFirstUpper(checkProperty);
      String _plus_1 = ("get" + _firstUpper);
      Iterable<JvmFeature> _findAllFeaturesByName = jvmType.findAllFeaturesByName(_plus_1);
      features = _findAllFeaturesByName;
    }
    boolean _or_3 = false;
    boolean _or_4 = false;
    boolean _equals_3 = Objects.equal(features, null);
    if (_equals_3) {
      _or_4 = true;
    } else {
      boolean _isEmpty_1 = IterableExtensions.isEmpty(features);
      _or_4 = _isEmpty_1;
    }
    if (_or_4) {
      _or_3 = true;
    } else {
      boolean _and = false;
      JvmFeature _head_1 = IterableExtensions.<JvmFeature>head(features);
      boolean _not_1 = (!(_head_1 instanceof JvmOperation));
      if (!_not_1) {
        _and = false;
      } else {
        JvmFeature _head_2 = IterableExtensions.<JvmFeature>head(features);
        boolean _not_2 = (!(_head_2 instanceof JvmField));
        _and = _not_2;
      }
      _or_3 = _and;
    }
    if (_or_3) {
      boolean _or_5 = false;
      if ((jvmType instanceof JvmPrimitiveType)) {
        _or_5 = true;
      } else {
        String _qualifiedName = jvmType.getQualifiedName();
        boolean _isPrimitive = this.isPrimitive(_qualifiedName);
        _or_5 = _isPrimitive;
      }
      if (_or_5) {
        return ValidationResult.OK;
      }
      boolean _isAbstract = jvmType.isAbstract();
      if (_isAbstract) {
        return ValidationResult.WARNING;
      }
      return ValidationResult.ERROR;
    }
    boolean _notEquals = (!Objects.equal(innerProperty, null));
    if (_notEquals) {
      JvmFeature _head_3 = IterableExtensions.<JvmFeature>head(features);
      if ((_head_3 instanceof JvmOperation)) {
        return ValidationResult.ERROR;
      }
      JvmFeature _head_4 = IterableExtensions.<JvmFeature>head(features);
      JvmField field = ((JvmField) _head_4);
      JvmTypeReference _type = field.getType();
      if ((_type instanceof JvmParameterizedTypeReference)) {
        JvmTypeReference _type_1 = field.getType();
        final JvmType type = ((JvmParameterizedTypeReference) _type_1).getType();
        if ((!(type instanceof JvmDeclaredType))) {
          InputOutput.<String>print((("checkClassProperty " + property) + ": "));
          InputOutput.<JvmType>println(type);
        } else {
          JvmTypeReference _type_2 = field.getType();
          final List<JvmTypeReference> typeArgs = ((JvmParameterizedTypeReference) _type_2).getArguments();
          boolean _and_1 = false;
          boolean _and_2 = false;
          boolean _notEquals_1 = (!Objects.equal(typeArgs, null));
          if (!_notEquals_1) {
            _and_2 = false;
          } else {
            boolean _isEmpty_2 = typeArgs.isEmpty();
            boolean _not_3 = (!_isEmpty_2);
            _and_2 = _not_3;
          }
          if (!_and_2) {
            _and_1 = false;
          } else {
            JvmTypeReference _head_5 = IterableExtensions.<JvmTypeReference>head(typeArgs);
            _and_1 = (_head_5 instanceof JvmParameterizedTypeReference);
          }
          if (_and_1) {
            JvmTypeReference _head_6 = IterableExtensions.<JvmTypeReference>head(typeArgs);
            final JvmType type2 = ((JvmParameterizedTypeReference) _head_6).getType();
            if ((!(type2 instanceof JvmDeclaredType))) {
              InputOutput.<String>print((("checkClassProperty2 " + property) + ": "));
              InputOutput.<JvmType>println(type2);
            } else {
              return this.checkClassProperty(((JvmDeclaredType) type2), innerProperty);
            }
          } else {
            return this.checkClassProperty(((JvmDeclaredType) type), innerProperty);
          }
        }
      }
      return ValidationResult.WARNING;
    }
    return ValidationResult.OK;
  }
  
  public Set<String> getFieldNamesForClass(final JvmDeclaredType jvmType) {
    final Set<String> result = CollectionLiterals.<String>newHashSet();
    Iterable<JvmField> _declaredFields = jvmType.getDeclaredFields();
    for (final JvmField field : _declaredFields) {
      String _simpleName = field.getSimpleName();
      result.add(_simpleName);
    }
    return result;
  }
  
  public ValidationResult checkOrderProperty(final String className, final String property, final URI uri, final Map<String, Map<String, String>> ordersCache, final Map<String, Class<?>> classesCache) {
    boolean _or = false;
    boolean _equals = Objects.equal(property, null);
    if (_equals) {
      _or = true;
    } else {
      PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
      boolean _equals_1 = Objects.equal(_pojoResolver, null);
      _or = _equals_1;
    }
    if (_or) {
      return ValidationResult.OK;
    }
    boolean _equals_2 = Objects.equal(className, null);
    if (_equals_2) {
      return ValidationResult.ERROR;
    }
    String _string = uri.toString();
    String _plus = (_string + className);
    Map<String, String> orders = ordersCache.get(_plus);
    boolean _equals_3 = Objects.equal(orders, null);
    if (_equals_3) {
      PojoResolver _pojoResolver_1 = this.pojoResolverFactory.getPojoResolver();
      Map<String, String> _orders = _pojoResolver_1.getOrders(className, uri);
      orders = _orders;
    }
    boolean _equals_4 = Objects.equal(orders, null);
    if (_equals_4) {
      return ValidationResult.WARNING;
    } else {
      String _string_1 = uri.toString();
      String _plus_1 = (_string_1 + className);
      ordersCache.put(_plus_1, orders);
    }
    final Map<String, String> _orders_1 = orders;
    Set<String> _keySet = orders.keySet();
    final Function1<String, Boolean> _function = new Function1<String, Boolean>() {
      @Override
      public Boolean apply(final String k) {
        String _get = _orders_1.get(k);
        return Boolean.valueOf(_get.equals(property));
      }
    };
    final String order = IterableExtensions.<String>findFirst(_keySet, _function);
    boolean _notEquals = (!Objects.equal(order, null));
    if (_notEquals) {
      return ValidationResult.OK;
    } else {
      return ValidationResult.ERROR;
    }
  }
  
  public ValidationResult checkOrderProperty(final JvmDeclaredType jvmType, final String property) {
    boolean _equals = Objects.equal(property, null);
    if (_equals) {
      return ValidationResult.OK;
    }
    boolean _equals_1 = Objects.equal(jvmType, null);
    if (_equals_1) {
      return ValidationResult.ERROR;
    }
    final Iterable<JvmFeature> features = jvmType.findAllFeaturesByName(("ORDER_BY_" + property));
    boolean _or = false;
    boolean _or_1 = false;
    boolean _equals_2 = Objects.equal(features, null);
    if (_equals_2) {
      _or_1 = true;
    } else {
      boolean _isEmpty = IterableExtensions.isEmpty(features);
      _or_1 = _isEmpty;
    }
    if (_or_1) {
      _or = true;
    } else {
      JvmFeature _head = IterableExtensions.<JvmFeature>head(features);
      boolean _not = (!(_head instanceof JvmField));
      _or = _not;
    }
    if (_or) {
      final Iterable<JvmDeclaredType> nestedTypes = jvmType.findAllNestedTypesByName("Order");
      boolean _or_2 = false;
      boolean _or_3 = false;
      boolean _equals_3 = Objects.equal(nestedTypes, null);
      if (_equals_3) {
        _or_3 = true;
      } else {
        boolean _isEmpty_1 = IterableExtensions.isEmpty(nestedTypes);
        _or_3 = _isEmpty_1;
      }
      if (_or_3) {
        _or_2 = true;
      } else {
        JvmDeclaredType _head_1 = IterableExtensions.<JvmDeclaredType>head(nestedTypes);
        boolean _not_1 = (!(_head_1 instanceof JvmEnumerationType));
        _or_2 = _not_1;
      }
      if (_or_2) {
        return ValidationResult.ERROR;
      }
      JvmDeclaredType _head_2 = IterableExtensions.<JvmDeclaredType>head(nestedTypes);
      final JvmEnumerationType type = ((JvmEnumerationType) _head_2);
      final Iterable<JvmFeature> features2 = type.findAllFeaturesByName(property);
      boolean _or_4 = false;
      boolean _or_5 = false;
      boolean _equals_4 = Objects.equal(features2, null);
      if (_equals_4) {
        _or_5 = true;
      } else {
        boolean _isEmpty_2 = IterableExtensions.isEmpty(features2);
        _or_5 = _isEmpty_2;
      }
      if (_or_5) {
        _or_4 = true;
      } else {
        JvmFeature _head_3 = IterableExtensions.<JvmFeature>head(features2);
        boolean _not_2 = (!(_head_3 instanceof JvmEnumerationLiteral));
        _or_4 = _not_2;
      }
      if (_or_4) {
        return ValidationResult.ERROR;
      }
    }
    return ValidationResult.OK;
  }
  
  @Check
  public void checkTableDefinition(final TableDefinitionModel tableDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(tableDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(tableDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<TableDefinitionModel> _tables = artifacts.getTables();
    for (final TableDefinitionModel table : _tables) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(table, null));
      if (!_notEquals) {
        _and = false;
      } else {
        _and = (table != tableDefinition);
      }
      if (_and) {
        String _name = tableDefinition.getName();
        String _name_1 = table.getName();
        boolean _equals_1 = _name.equals(_name_1);
        if (_equals_1) {
          String _name_2 = tableDefinition.getName();
          String _plus = ("Duplicate name : " + _name_2);
          String _plus_1 = (_plus + "[table]");
          this.error(_plus_1, 
            ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
    boolean _and_1 = false;
    boolean _isResolveDb = this.isResolveDb(tableDefinition);
    if (!_isResolveDb) {
      _and_1 = false;
    } else {
      String _table = tableDefinition.getTable();
      boolean _checkTable = this.dbResolver.checkTable(tableDefinition, _table);
      boolean _not = (!_checkTable);
      _and_1 = _not;
    }
    if (_and_1) {
      String _table_1 = tableDefinition.getTable();
      String _plus_2 = ("Cannot find table in DB : " + _table_1);
      this.error(_plus_2, 
        ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__TABLE);
    }
  }
  
  @Check
  public void checkProcedureDefinition(final ProcedureDefinitionModel procedureDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(procedureDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(procedureDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<ProcedureDefinitionModel> _procedures = artifacts.getProcedures();
    for (final ProcedureDefinitionModel procedure : _procedures) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(procedure, null));
      if (!_notEquals) {
        _and = false;
      } else {
        _and = (procedure != procedureDefinition);
      }
      if (_and) {
        String _name = procedureDefinition.getName();
        String _name_1 = procedure.getName();
        boolean _equals_1 = _name.equals(_name_1);
        if (_equals_1) {
          String _name_2 = procedureDefinition.getName();
          String _plus = ("Duplicate name : " + _name_2);
          String _plus_1 = (_plus + "[procedure]");
          this.error(_plus_1, 
            ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
    boolean _and_1 = false;
    boolean _isResolveDb = this.isResolveDb(procedureDefinition);
    if (!_isResolveDb) {
      _and_1 = false;
    } else {
      String _table = procedureDefinition.getTable();
      boolean _checkProcedure = this.dbResolver.checkProcedure(procedureDefinition, _table);
      boolean _not = (!_checkProcedure);
      _and_1 = _not;
    }
    if (_and_1) {
      String _table_1 = procedureDefinition.getTable();
      String _plus_2 = ("Cannot find procedure in DB : " + _table_1);
      this.error(_plus_2, 
        ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME);
    }
  }
  
  @Check
  public void checkFunctionDefinition(final FunctionDefinitionModel functionDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(functionDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(functionDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<FunctionDefinitionModel> _functions = artifacts.getFunctions();
    for (final FunctionDefinitionModel function : _functions) {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(function, null));
      if (!_notEquals) {
        _and = false;
      } else {
        _and = (function != functionDefinition);
      }
      if (_and) {
        String _name = functionDefinition.getName();
        String _name_1 = function.getName();
        boolean _equals_1 = _name.equals(_name_1);
        if (_equals_1) {
          String _name_2 = functionDefinition.getName();
          String _plus = ("Duplicate name : " + _name_2);
          String _plus_1 = (_plus + "[function]");
          this.error(_plus_1, 
            ProcessorMetaPackage.Literals.FUNCTION_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
  }
  
  public void _checkDatabaseTable(final DatabaseTable databaseTable) {
    boolean _isResolveDb = this.isResolveDb(databaseTable);
    boolean _not = (!_isResolveDb);
    if (_not) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(databaseTable, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final MetaStatement statement = EcoreUtil2.<MetaStatement>getContainerOfType(databaseTable, MetaStatement.class);
    final Artifacts artifacts = this.getArtifacts(statement);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    final String tableName = databaseTable.getName();
    List<String> _tokensFromModifier = Utils.getTokensFromModifier(statement, Constants.TABLE_USAGE);
    final Function1<String, TableDefinition> _function = new Function1<String, TableDefinition>() {
      @Override
      public TableDefinition apply(final String value) {
        Map<String, TableDefinition> _modelTables = ProcessorMetaValidator.this.modelProperty.getModelTables(artifacts);
        return _modelTables.get(value);
      }
    };
    final List<TableDefinition> tableDefinitions = ListExtensions.<String, TableDefinition>map(_tokensFromModifier, _function);
    final Function1<TableDefinition, Boolean> _function_1 = new Function1<TableDefinition, Boolean>() {
      @Override
      public Boolean apply(final TableDefinition it) {
        String _table = it.getTable();
        return Boolean.valueOf(Objects.equal(_table, tableName));
      }
    };
    final TableDefinition tableDefinition = IterableExtensions.<TableDefinition>findFirst(tableDefinitions, _function_1);
    boolean _or = false;
    boolean _equals_1 = Objects.equal(tableDefinition, null);
    if (_equals_1) {
      _or = true;
    } else {
      boolean _checkTable = this.dbResolver.checkTable(databaseTable, tableName);
      boolean _not_1 = (!_checkTable);
      _or = _not_1;
    }
    if (_or) {
      this.error(("Cannot find table in DB : " + tableName), ProcessorMetaPackage.Literals.DATABASE_TABLE__NAME);
    }
  }
  
  public void _checkDatabaseColumn(final DatabaseColumn databaseColumn) {
    boolean _isResolveDb = this.isResolveDb(databaseColumn);
    boolean _not = (!_isResolveDb);
    if (_not) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(databaseColumn, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    String prefix = databaseColumn.getName();
    String columnName = ((String) null);
    final int pos = prefix.indexOf(".");
    if ((pos > 0)) {
      String _name = databaseColumn.getName();
      String _substring = _name.substring(0, pos);
      prefix = _substring;
      String _name_1 = databaseColumn.getName();
      String _substring_1 = _name_1.substring((pos + 1));
      columnName = _substring_1;
    } else {
      prefix = null;
      String _name_2 = databaseColumn.getName();
      columnName = _name_2;
    }
    final MetaStatement statement = EcoreUtil2.<MetaStatement>getContainerOfType(databaseColumn, MetaStatement.class);
    final Artifacts artifacts = this.getArtifacts(statement);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    final String value = Utils.getTokenFromModifier(statement, Constants.TABLE_USAGE, prefix);
    TableDefinition _xifexpression = null;
    boolean _notEquals = (!Objects.equal(value, null));
    if (_notEquals) {
      Map<String, TableDefinition> _modelTables = this.modelProperty.getModelTables(artifacts);
      _xifexpression = _modelTables.get(value);
    }
    final TableDefinition tableDefinition = _xifexpression;
    String _xifexpression_1 = null;
    boolean _notEquals_1 = (!Objects.equal(tableDefinition, null));
    if (_notEquals_1) {
      _xifexpression_1 = tableDefinition.getTable();
    }
    final String tableName = _xifexpression_1;
    boolean _or = false;
    boolean _equals_1 = Objects.equal(tableName, null);
    if (_equals_1) {
      _or = true;
    } else {
      boolean _checkColumn = this.dbResolver.checkColumn(databaseColumn, tableName, columnName);
      boolean _not_1 = (!_checkColumn);
      _or = _not_1;
    }
    if (_or) {
      String _name_3 = databaseColumn.getName();
      String _plus = ("Cannot find column in DB : " + _name_3);
      String _plus_1 = (_plus + "[");
      String _plus_2 = (_plus_1 + tableName);
      String _plus_3 = (_plus_2 + "]");
      this.error(_plus_3, 
        ProcessorMetaPackage.Literals.DATABASE_COLUMN__NAME);
    }
  }
  
  public Artifacts getArtifacts(final EObject model) {
    final EObject root = EcoreUtil.getRootContainer(model);
    if ((!(root instanceof Artifacts))) {
      return null;
    }
    return ((Artifacts) root);
  }
  
  public boolean isPrimitive(final Class<?> clazz) {
    boolean _equals = Objects.equal(clazz, null);
    if (_equals) {
      return true;
    }
    boolean _equals_1 = Objects.equal(clazz, String.class);
    if (_equals_1) {
      return true;
    }
    boolean _equals_2 = Objects.equal(clazz, Byte.class);
    if (_equals_2) {
      return true;
    }
    boolean _equals_3 = Objects.equal(clazz, Short.class);
    if (_equals_3) {
      return true;
    }
    boolean _equals_4 = Objects.equal(clazz, Integer.class);
    if (_equals_4) {
      return true;
    }
    boolean _equals_5 = Objects.equal(clazz, Long.class);
    if (_equals_5) {
      return true;
    }
    boolean _equals_6 = Objects.equal(clazz, Double.class);
    if (_equals_6) {
      return true;
    }
    boolean _equals_7 = Objects.equal(clazz, Float.class);
    if (_equals_7) {
      return true;
    }
    boolean _equals_8 = Objects.equal(clazz, Boolean.class);
    if (_equals_8) {
      return true;
    }
    boolean _equals_9 = Objects.equal(clazz, Date.class);
    if (_equals_9) {
      return true;
    }
    boolean _equals_10 = Objects.equal(clazz, java.sql.Date.class);
    if (_equals_10) {
      return true;
    }
    boolean _equals_11 = Objects.equal(clazz, Time.class);
    if (_equals_11) {
      return true;
    }
    boolean _equals_12 = Objects.equal(clazz, Timestamp.class);
    if (_equals_12) {
      return true;
    }
    boolean _equals_13 = Objects.equal(clazz, Blob.class);
    if (_equals_13) {
      return true;
    }
    boolean _equals_14 = Objects.equal(clazz, Clob.class);
    if (_equals_14) {
      return true;
    }
    boolean _equals_15 = Objects.equal(clazz, BigDecimal.class);
    if (_equals_15) {
      return true;
    }
    boolean _equals_16 = Objects.equal(clazz, BigInteger.class);
    if (_equals_16) {
      return true;
    }
    return false;
  }
  
  public boolean isPrimitive(final String name) {
    boolean _equals = Objects.equal(name, null);
    if (_equals) {
      return true;
    }
    boolean _equals_1 = Objects.equal(name, "java.lang.String");
    if (_equals_1) {
      return true;
    }
    boolean _equals_2 = Objects.equal(name, "java.lang.Byte");
    if (_equals_2) {
      return true;
    }
    boolean _equals_3 = Objects.equal(name, "java.lang.Short");
    if (_equals_3) {
      return true;
    }
    boolean _equals_4 = Objects.equal(name, "java.lang.Integer");
    if (_equals_4) {
      return true;
    }
    boolean _equals_5 = Objects.equal(name, "java.lang.Long");
    if (_equals_5) {
      return true;
    }
    boolean _equals_6 = Objects.equal(name, "java.lang.Double");
    if (_equals_6) {
      return true;
    }
    boolean _equals_7 = Objects.equal(name, "java.lang.Float");
    if (_equals_7) {
      return true;
    }
    boolean _equals_8 = Objects.equal(name, "java.lang.Boolean");
    if (_equals_8) {
      return true;
    }
    boolean _equals_9 = Objects.equal(name, "java.util.Date");
    if (_equals_9) {
      return true;
    }
    boolean _equals_10 = Objects.equal(name, "java.sql.Date");
    if (_equals_10) {
      return true;
    }
    boolean _equals_11 = Objects.equal(name, "java.sql.Time");
    if (_equals_11) {
      return true;
    }
    boolean _equals_12 = Objects.equal(name, "java.sql.Timestamp");
    if (_equals_12) {
      return true;
    }
    boolean _equals_13 = Objects.equal(name, "java.sql.Blob");
    if (_equals_13) {
      return true;
    }
    boolean _equals_14 = Objects.equal(name, "java.sql.Clob");
    if (_equals_14) {
      return true;
    }
    boolean _equals_15 = Objects.equal(name, "java.math.BigDecimal");
    if (_equals_15) {
      return true;
    }
    boolean _equals_16 = Objects.equal(name, "java.math.BigInteger");
    if (_equals_16) {
      return true;
    }
    return false;
  }
  
  public boolean isResolvePojo(final EObject model) {
    return this.modelProperty.isDoResolvePojo(model);
  }
  
  public boolean isResolveDb(final EObject model) {
    return this.dbResolver.isResolveDb(model);
  }
}
