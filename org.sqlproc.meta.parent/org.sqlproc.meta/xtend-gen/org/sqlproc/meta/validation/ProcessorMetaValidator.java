/**
 * generated by Xtext
 */
package org.sqlproc.meta.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmEnumerationLiteral;
import org.eclipse.xtext.common.types.JvmEnumerationType;
import org.eclipse.xtext.common.types.JvmFeature;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmPrimitiveType;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.sqlproc.meta.processorMeta.AnnotationDefinitionModel;
import org.sqlproc.meta.processorMeta.Artifacts;
import org.sqlproc.meta.processorMeta.Column;
import org.sqlproc.meta.processorMeta.Constant;
import org.sqlproc.meta.processorMeta.DatabaseColumn;
import org.sqlproc.meta.processorMeta.DatabaseTable;
import org.sqlproc.meta.processorMeta.ExtendedColumn;
import org.sqlproc.meta.processorMeta.FunctionDefinitionModel;
import org.sqlproc.meta.processorMeta.Identifier;
import org.sqlproc.meta.processorMeta.IfSql;
import org.sqlproc.meta.processorMeta.IfSqlFragment;
import org.sqlproc.meta.processorMeta.MappingColumn;
import org.sqlproc.meta.processorMeta.MappingRule;
import org.sqlproc.meta.processorMeta.MetaSql;
import org.sqlproc.meta.processorMeta.MetaStatement;
import org.sqlproc.meta.processorMeta.OptionalFeature;
import org.sqlproc.meta.processorMeta.OrdSql;
import org.sqlproc.meta.processorMeta.PojoDefinitionModel;
import org.sqlproc.meta.processorMeta.ProcedureDefinitionModel;
import org.sqlproc.meta.processorMeta.ProcessorMetaPackage;
import org.sqlproc.meta.processorMeta.Property;
import org.sqlproc.meta.processorMeta.SqlFragment;
import org.sqlproc.meta.processorMeta.TableDefinitionModel;
import org.sqlproc.meta.util.Utils;
import org.sqlproc.meta.validation.AbstractProcessorMetaValidator;
import org.sqlproc.meta.validation.ValidationResult;
import org.sqlproc.plugin.lib.property.ModelProperty;
import org.sqlproc.plugin.lib.property.PojoDefinition;
import org.sqlproc.plugin.lib.property.TableDefinition;
import org.sqlproc.plugin.lib.resolver.DbResolver;
import org.sqlproc.plugin.lib.resolver.PojoResolver;
import org.sqlproc.plugin.lib.resolver.PojoResolverFactory;
import org.sqlproc.plugin.lib.util.CommonUtils;
import org.sqlproc.plugin.lib.util.Constants;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class ProcessorMetaValidator extends AbstractProcessorMetaValidator {
  @Inject
  private PojoResolverFactory pojoResolverFactory;
  
  @Inject
  private DbResolver dbResolver;
  
  @Inject
  private ModelProperty modelProperty;
  
  private final HashSet<String> F_TYPES = CollectionLiterals.<String>newHashSet("set", "update", "values", "where", "columns", "set=opt", "where=opt");
  
  @Check
  public void checkMetaSqlFtype(final MetaSql metaSql) {
    String _ftype = metaSql.getFtype();
    boolean _equals = Objects.equal(_ftype, null);
    if (_equals) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(metaSql, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    if (((!Objects.equal(metaSql.getFtype(), null)) && (!this.F_TYPES.contains(metaSql.getFtype().toLowerCase())))) {
      String _ftype_1 = metaSql.getFtype();
      String _plus = ("Invalid ftype : " + _ftype_1);
      this.error(_plus, ProcessorMetaPackage.Literals.META_SQL__FTYPE);
    }
  }
  
  @Check
  public void checkUniqueMetaStatement(final MetaStatement metaStatement) {
    boolean _skipVerification = CommonUtils.skipVerification(metaStatement, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(metaStatement);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<MetaStatement> _statements = artifacts.getStatements();
    for (final MetaStatement metaStmt : _statements) {
      if (((!Objects.equal(metaStmt, null)) && (metaStmt != metaStatement))) {
        boolean _equalsStatement = this.equalsStatement(metaStatement, metaStmt);
        if (_equalsStatement) {
          String _name = metaStatement.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[");
          String _type = metaStatement.getType();
          String _plus_2 = (_plus_1 + _type);
          String _plus_3 = (_plus_2 + "]");
          this.error(_plus_3, 
            ProcessorMetaPackage.Literals.META_STATEMENT__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsStatement(final MetaStatement statement1, final MetaStatement statement2) {
    if ((Objects.equal(statement1, null) && Objects.equal(statement2, null))) {
      return true;
    }
    if ((Objects.equal(statement1, null) || Objects.equal(statement1.getName(), null))) {
      return false;
    }
    if ((Objects.equal(statement2, null) || Objects.equal(statement2.getName(), null))) {
      return false;
    }
    if ((statement1.getName().equals(statement2.getName()) && statement1.getType().equals(statement2.getType()))) {
      return this.equalsModifiers(statement1.getModifiers(), statement2.getModifiers());
    }
    return false;
  }
  
  @Check
  public void checkUniqueMappingRule(final MappingRule mappingRule) {
    boolean _skipVerification = CommonUtils.skipVerification(mappingRule, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(mappingRule);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<MappingRule> _mappings = artifacts.getMappings();
    for (final MappingRule rule : _mappings) {
      if (((!Objects.equal(rule, null)) && (rule != mappingRule))) {
        boolean _equalsRule = this.equalsRule(mappingRule, rule);
        if (_equalsRule) {
          String _name = mappingRule.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[");
          String _type = mappingRule.getType();
          String _plus_2 = (_plus_1 + _type);
          String _plus_3 = (_plus_2 + "]");
          this.error(_plus_3, 
            ProcessorMetaPackage.Literals.MAPPING_RULE__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsRule(final MappingRule rule1, final MappingRule rule2) {
    if ((Objects.equal(rule1, null) && Objects.equal(rule2, null))) {
      return true;
    }
    if ((Objects.equal(rule1, null) || Objects.equal(rule1.getName(), null))) {
      return false;
    }
    if ((Objects.equal(rule2, null) || Objects.equal(rule2.getName(), null))) {
      return false;
    }
    if ((rule1.getName().equals(rule2.getName()) && rule1.getType().equals(rule2.getType()))) {
      return this.equalsModifiers(rule1.getModifiers(), rule2.getModifiers());
    }
    return false;
  }
  
  @Check
  public void checkUniqueOptionalFeature(final OptionalFeature optionalFeature) {
    boolean _skipVerification = CommonUtils.skipVerification(optionalFeature, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(optionalFeature);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<OptionalFeature> _features = artifacts.getFeatures();
    for (final OptionalFeature feature : _features) {
      if (((!Objects.equal(feature, null)) && (!Objects.equal(feature, optionalFeature)))) {
        boolean _equalsFeature = this.equalsFeature(optionalFeature, feature);
        if (_equalsFeature) {
          String _name = optionalFeature.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[");
          String _type = optionalFeature.getType();
          String _plus_2 = (_plus_1 + _type);
          String _plus_3 = (_plus_2 + "]");
          this.error(_plus_3, 
            ProcessorMetaPackage.Literals.OPTIONAL_FEATURE__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsFeature(final OptionalFeature feature1, final OptionalFeature feature2) {
    if ((Objects.equal(feature1, null) && Objects.equal(feature2, null))) {
      return true;
    }
    if ((Objects.equal(feature1, null) || Objects.equal(feature1.getName(), null))) {
      return false;
    }
    if ((Objects.equal(feature2, null) || Objects.equal(feature2.getName(), null))) {
      return false;
    }
    if ((feature1.getName().equals(feature2.getName()) && feature1.getType().equals(feature2.getType()))) {
      return this.equalsModifiers(feature1.getModifiers(), feature2.getModifiers());
    }
    return false;
  }
  
  @Check
  public void checkUniquePojoDefinition(final PojoDefinitionModel pojoDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(pojoDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(pojoDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<PojoDefinitionModel> _pojos = artifacts.getPojos();
    for (final PojoDefinitionModel definition : _pojos) {
      if (((!Objects.equal(definition, null)) && (definition != pojoDefinition))) {
        boolean _equals_1 = pojoDefinition.getName().equals(definition.getName());
        if (_equals_1) {
          String _name = pojoDefinition.getName();
          String _plus = ("Duplicate name : " + _name);
          this.error(_plus, 
            ProcessorMetaPackage.Literals.POJO_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
  }
  
  @Check
  public void checkUniqueAnnotationDefinition(final AnnotationDefinitionModel annotationDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(annotationDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(annotationDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<AnnotationDefinitionModel> _annotations = artifacts.getAnnotations();
    for (final AnnotationDefinitionModel definition : _annotations) {
      if (((!Objects.equal(definition, null)) && (definition != annotationDefinition))) {
        boolean _equals_1 = annotationDefinition.getName().equals(definition.getName());
        if (_equals_1) {
          String _name = annotationDefinition.getName();
          String _plus = ("Duplicate name : " + _name);
          this.error(_plus, 
            ProcessorMetaPackage.Literals.ANNOTATION_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
  }
  
  @Check
  public void checkUniqueProperty(final Property property) {
    boolean _skipVerification = CommonUtils.skipVerification(property, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(property);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<Property> _properties = artifacts.getProperties();
    for (final Property prop : _properties) {
      if (((!Objects.equal(prop, null)) && (prop != property))) {
        if ((((((prop.getName().equals(property.getName()) && (!prop.getName().startsWith("pojogen"))) && (!prop.getName().startsWith("database"))) && (!prop.getName().startsWith("metagen"))) && (!prop.getName().startsWith("daogen"))) && (!prop.getName().startsWith("replace-text")))) {
          String _name = property.getName();
          String _plus = ("Duplicate name : " + _name);
          this.error(_plus, ProcessorMetaPackage.Literals.PROPERTY__NAME);
          return;
        }
      }
    }
  }
  
  public boolean equalsModifiers(final List<String> modifiers1, final List<String> modifiers2) {
    final List<String> filteredModifiers1 = this.filteredModifiers(modifiers1);
    final List<String> filteredModifiers2 = this.filteredModifiers(modifiers2);
    if ((Objects.equal(filteredModifiers1, null) && Objects.equal(filteredModifiers2, null))) {
      return true;
    }
    boolean _equals = Objects.equal(filteredModifiers1, null);
    if (_equals) {
      return false;
    }
    boolean _equals_1 = Objects.equal(filteredModifiers2, null);
    if (_equals_1) {
      return false;
    }
    if ((filteredModifiers1.isEmpty() && filteredModifiers2.isEmpty())) {
      return true;
    }
    for (final String modifier1 : filteredModifiers1) {
      for (final String modifier2 : filteredModifiers2) {
        boolean _equals_2 = modifier1.equals(modifier2);
        if (_equals_2) {
          return true;
        }
      }
    }
    return false;
  }
  
  public List<String> filteredModifiers(final List<String> modifiers) {
    boolean _equals = Objects.equal(modifiers, null);
    if (_equals) {
      return null;
    }
    final ArrayList<String> filteredModifiers = CollectionLiterals.<String>newArrayList();
    final Consumer<String> _function = (String modifier) -> {
      int _indexOf = modifier.indexOf("=");
      boolean _lessThan = (_indexOf < 0);
      if (_lessThan) {
        filteredModifiers.add(modifier);
      }
    };
    modifiers.forEach(_function);
    return filteredModifiers;
  }
  
  public String getClass(final PojoDefinitionModel pojo) {
    JvmType _classx = pojo.getClassx();
    boolean _notEquals = (!Objects.equal(_classx, null));
    if (_notEquals) {
      return pojo.getClassx().getQualifiedName();
    }
    return pojo.getClass_();
  }
  
  @Check
  public void checkMetaStatement(final MetaStatement statement) {
    if ((Objects.equal(statement.getModifiers(), null) || statement.getModifiers().isEmpty())) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(statement, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(statement);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    Resource _eResource = statement.eResource();
    URI _uRI = null;
    if (_eResource!=null) {
      _uRI=_eResource.getURI();
    }
    final URI uri = _uRI;
    final Map<String, PropertyDescriptor[]> descriptorsCache = new HashMap<String, PropertyDescriptor[]>();
    final Map<String, Class<?>> classesCache = new HashMap<String, Class<?>>();
    final Map<String, Map<String, String>> ordersCache = new HashMap<String, Map<String, String>>();
    int index = 0;
    String identPojoName = null;
    PojoDefinition identPojo = null;
    String indexPojoName = null;
    PojoDefinition indexPojo = null;
    String colPojoName = null;
    PojoDefinition colPojo = null;
    String constPojoName = null;
    PojoDefinition constPojo = null;
    final TreeMap<String, TableDefinition> tablesPojo = new TreeMap<String, TableDefinition>();
    final TreeMap<String, TableDefinition> tablesPrefixPojo = new TreeMap<String, TableDefinition>();
    EList<String> _modifiers = statement.getModifiers();
    for (final String modifier : _modifiers) {
      {
        final String[] values = modifier.split("=");
        int _length = values.length;
        boolean _greaterThan = (_length > 1);
        if (_greaterThan) {
          final String key = values[0];
          final String value = values[1];
          boolean _equals_1 = Constants.IDENTIFIER_USAGE.equals(key);
          if (_equals_1) {
            identPojo = this.modelProperty.getModelPojos(artifacts).get(value);
            boolean _equals_2 = Objects.equal(identPojo, null);
            if (_equals_2) {
              this.error((((("Cannot find pojo : " + value) + "[") + Constants.IDENTIFIER_USAGE) + "]"), 
                ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
            } else {
              identPojoName = value;
            }
          }
          boolean _equals_3 = Constants.INDEX_USAGE.equals(key);
          if (_equals_3) {
            indexPojo = this.modelProperty.getModelPojos(artifacts).get(value);
            boolean _equals_4 = Objects.equal(indexPojo, null);
            if (_equals_4) {
              this.error((((("Cannot find pojo : " + value) + "[") + Constants.INDEX_USAGE) + "]"), 
                ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
            } else {
              indexPojoName = value;
            }
          } else {
            boolean _equals_5 = Constants.COLUMN_USAGE.equals(key);
            if (_equals_5) {
              colPojo = this.modelProperty.getModelPojos(artifacts).get(value);
              boolean _equals_6 = Objects.equal(colPojo, null);
              if (_equals_6) {
                this.error((((("Cannot find pojo : " + value) + "[") + Constants.COLUMN_USAGE) + "]"), 
                  ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
              } else {
                colPojoName = value;
              }
            } else {
              boolean _equals_7 = Constants.CONSTANT_USAGE.equals(key);
              if (_equals_7) {
                constPojo = this.modelProperty.getModelPojos(artifacts).get(value);
                boolean _equals_8 = Objects.equal(constPojo, null);
                if (_equals_8) {
                  this.error((((("Cannot find pojo : " + value) + "[") + Constants.CONSTANT_USAGE) + "]"), 
                    ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
                } else {
                  constPojoName = value;
                }
              } else {
                boolean _equals_9 = Constants.TABLE_USAGE.equals(key);
                if (_equals_9) {
                  String _xifexpression = null;
                  int _length_1 = values.length;
                  boolean _greaterThan_1 = (_length_1 > 2);
                  if (_greaterThan_1) {
                    _xifexpression = values[2];
                  } else {
                    _xifexpression = "_DEFAULT_";
                  }
                  final String prefix = _xifexpression;
                  final TableDefinition table = this.modelProperty.getModelTables(artifacts).get(value);
                  boolean _equals_10 = Objects.equal(table, null);
                  if (_equals_10) {
                    this.error((((("Cannot find table : " + value) + "[") + Constants.TABLE_USAGE) + "]"), 
                      ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index);
                  } else {
                    tablesPojo.put(value, table);
                    tablesPrefixPojo.put(prefix, table);
                  }
                }
              }
            }
          }
          index = (index + 1);
        }
      }
    }
    boolean _equals_1 = Objects.equal(indexPojo, null);
    if (_equals_1) {
      indexPojo = identPojo;
      indexPojoName = identPojoName;
    }
    boolean _isOldPojoValidator = this.modelProperty.isOldPojoValidator(statement);
    final boolean newPojoValidator = (!_isOldPojoValidator);
    boolean _notEquals = (!Objects.equal(identPojo, null));
    if (_notEquals) {
      final List<Identifier> identifiers = EcoreUtil2.<Identifier>getAllContentsOfType(statement, Identifier.class);
      final PojoDefinition pojo = identPojo;
      final String pojoName = identPojoName;
      final Consumer<Identifier> _function = (Identifier identifier) -> {
        this.checkIdentifier(identifier, pojo, pojoName, statement, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
      };
      identifiers.forEach(_function);
    }
    boolean _notEquals_1 = (!Objects.equal(indexPojo, null));
    if (_notEquals_1) {
      final List<OrdSql> orders = EcoreUtil2.<OrdSql>getAllContentsOfType(statement, OrdSql.class);
      final PojoDefinition pojo_1 = indexPojo;
      final String pojoName_1 = indexPojoName;
      final Consumer<OrdSql> _function_1 = (OrdSql order) -> {
        this.checkOrder(order, pojo_1, pojoName_1, statement, newPojoValidator, artifacts, uri, ordersCache, classesCache);
      };
      orders.forEach(_function_1);
    }
    boolean _notEquals_2 = (!Objects.equal(colPojo, null));
    if (_notEquals_2) {
      final List<Column> columns = EcoreUtil2.<Column>getAllContentsOfType(statement, Column.class);
      final PojoDefinition pojo_2 = colPojo;
      final String pojoName_2 = colPojoName;
      final Consumer<Column> _function_2 = (Column column) -> {
        this.checkColumn(column, pojo_2, pojoName_2, statement, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
      };
      columns.forEach(_function_2);
    }
    boolean _notEquals_3 = (!Objects.equal(constPojo, null));
    if (_notEquals_3) {
      final List<Constant> constants = EcoreUtil2.<Constant>getAllContentsOfType(statement, Constant.class);
      final PojoDefinition pojo_3 = constPojo;
      final String pojoName_3 = constPojoName;
      final Consumer<Constant> _function_3 = (Constant constant) -> {
        this.checkConstant(constant, pojo_3, pojoName_3, statement, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
      };
      constants.forEach(_function_3);
    }
    boolean _isResolveDb = this.isResolveDb(statement);
    if (_isResolveDb) {
      this.checkTablesColumns(tablesPojo, tablesPrefixPojo, statement);
    }
  }
  
  public void checkTablesColumns(final TreeMap<String, TableDefinition> tablesPojo, final TreeMap<String, TableDefinition> tablesPrefixPojo, final MetaStatement statement) {
    final List<DatabaseTable> tables = EcoreUtil2.<DatabaseTable>getAllContentsOfType(statement, DatabaseTable.class);
    final Consumer<DatabaseTable> _function = (DatabaseTable table) -> {
      final String tableName = table.getName();
      final Function1<TableDefinition, Boolean> _function_1 = (TableDefinition it) -> {
        String _table = it.getTable();
        return Boolean.valueOf(Objects.equal(_table, tableName));
      };
      final TableDefinition tableDefinition = IterableExtensions.<TableDefinition>findFirst(tablesPojo.values(), _function_1);
      if ((Objects.equal(tableDefinition, null) || (!this.dbResolver.checkTable(statement, tableName)))) {
        this.error(("Cannot find table in DB : " + tableName), table, ProcessorMetaPackage.Literals.DATABASE_TABLE__NAME);
      }
    };
    tables.forEach(_function);
    final List<DatabaseColumn> columns = EcoreUtil2.<DatabaseColumn>getAllContentsOfType(statement, DatabaseColumn.class);
    final Consumer<DatabaseColumn> _function_1 = (DatabaseColumn column) -> {
      final int pos = column.getName().indexOf(".");
      String _xifexpression = null;
      if ((pos > 0)) {
        _xifexpression = column.getName().substring(0, pos);
      } else {
        _xifexpression = "_DEFAULT_";
      }
      final String prefix = _xifexpression;
      String _xifexpression_1 = null;
      if ((pos > 0)) {
        _xifexpression_1 = column.getName().substring((pos + 1));
      } else {
        _xifexpression_1 = column.getName();
      }
      final String columnName = _xifexpression_1;
      final TableDefinition tableDefinition = tablesPrefixPojo.get(prefix);
      String _xifexpression_2 = null;
      boolean _notEquals = (!Objects.equal(tableDefinition, null));
      if (_notEquals) {
        _xifexpression_2 = tableDefinition.getTable();
      }
      final String tableName = _xifexpression_2;
      if ((Objects.equal(tableName, null) || (!this.dbResolver.checkColumn(column, tableName, columnName)))) {
        String _name = column.getName();
        String _plus = ("Cannot find column in DB : " + _name);
        String _plus_1 = (_plus + "[");
        String _plus_2 = (_plus_1 + tableName);
        String _plus_3 = (_plus_2 + "]");
        this.error(_plus_3, column, ProcessorMetaPackage.Literals.DATABASE_COLUMN__NAME);
      }
    };
    columns.forEach(_function_1);
  }
  
  public void checkIdentifier(final Identifier identifier, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(identifier);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String identifierName = identifier.getName();
    final String identifierUsageClass = pojo.getQualifiedName();
    ValidationResult validationResult = null;
    boolean _notEquals = (!Objects.equal(identifierUsageClass, null));
    if (_notEquals) {
      if ((newPojoValidator && (pojo.getClassx() instanceof JvmDeclaredType))) {
        JvmType _classx = pojo.getClassx();
        validationResult = this.checkClassProperty(((JvmDeclaredType) _classx), identifierName);
      } else {
        validationResult = this.checkClassProperty(identifierUsageClass, identifierName, uri, descriptorsCache, classesCache);
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem property : " + identifierName) + "[") + identifierUsageClass) + "]"), identifier, ProcessorMetaPackage.Literals.IDENTIFIER__NAME);
            break;
          case ERROR:
            this.error((((("Cannot find property : " + identifierName) + "[") + identifierUsageClass) + "]"), identifier, ProcessorMetaPackage.Literals.IDENTIFIER__NAME);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_1 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_1) {
      this.error(("Cannot check input form attribute : " + identifierName), identifier, ProcessorMetaPackage.Literals.IDENTIFIER__NAME);
    }
  }
  
  public void checkOrder(final OrdSql order, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, Map<String, String>> ordersCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(order);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String identifierName = order.getIdent();
    final String identifierUsageClass = pojo.getQualifiedName();
    ValidationResult validationResult = null;
    boolean _notEquals = (!Objects.equal(identifierUsageClass, null));
    if (_notEquals) {
      if ((newPojoValidator && (pojo.getClassx() instanceof JvmDeclaredType))) {
        JvmType _classx = pojo.getClassx();
        validationResult = this.checkOrderProperty(((JvmDeclaredType) _classx), identifierName);
      } else {
        this.checkOrderProperty(identifierUsageClass, identifierName, uri, ordersCache, classesCache);
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem order : " + identifierName) + "[") + identifierUsageClass) + "]"), order, ProcessorMetaPackage.Literals.ORD_SQL__IDENT);
            break;
          case ERROR:
            this.warning((((("Cannot find order : " + identifierName) + "[") + identifierUsageClass) + "]"), order, ProcessorMetaPackage.Literals.ORD_SQL__IDENT);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_1 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_1) {
      this.error(("Cannot check order identifier : " + identifierName), order, ProcessorMetaPackage.Literals.ORD_SQL__IDENT);
    }
  }
  
  public void checkColumn(final Column column, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(column);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String columnName = Utils.getName(column);
    boolean _isNumber = Utils.isNumber(columnName);
    if (_isNumber) {
      return;
    }
    String _xifexpression = null;
    boolean _notEquals = (!Objects.equal(pojo, null));
    if (_notEquals) {
      _xifexpression = pojo.getQualifiedName();
    }
    final String columnUsageClass = _xifexpression;
    ValidationResult validationResult = null;
    boolean _notEquals_1 = (!Objects.equal(columnUsageClass, null));
    if (_notEquals_1) {
      if ((newPojoValidator && (pojo.getClassx() instanceof JvmDeclaredType))) {
        JvmType _classx = pojo.getClassx();
        validationResult = this.checkClassProperty(((JvmDeclaredType) _classx), columnName);
      } else {
        validationResult = this.checkClassProperty(columnUsageClass, columnName, uri, descriptorsCache, classesCache);
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
            break;
          case ERROR:
            this.checkColumnGType(column, columnName, columnUsageClass, statement);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_2 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_2) {
      this.error(("Cannot check result class attribute : " + columnName), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
    }
  }
  
  public void checkColumnGType(final Column column, final String columnName, final String columnUsageClass, final MetaStatement statement) {
    if ((Objects.equal(statement.getStatement(), null) || Objects.equal(statement.getStatement().getSqls(), null))) {
      return;
    }
    EList<SqlFragment> _sqls = statement.getStatement().getSqls();
    for (final SqlFragment stmt : _sqls) {
      {
        if ((((!Objects.equal(stmt.getCol(), null)) && (!Objects.equal(stmt.getCol().getColumns(), null))) && (!Objects.equal(stmt.getCol().getColumns(), null)))) {
          EList<ExtendedColumn> _columns = stmt.getCol().getColumns();
          for (final ExtendedColumn _col : _columns) {
            EList<String> _modifiers = _col.getModifiers();
            boolean _notEquals = (!Objects.equal(_modifiers, null));
            if (_notEquals) {
              EList<String> _modifiers_1 = _col.getModifiers();
              for (final String mod : _modifiers_1) {
                int _indexOf = mod.indexOf("gtype");
                boolean _greaterEqualsThan = (_indexOf >= 0);
                if (_greaterEqualsThan) {
                  this.warning((((("Problem property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
                  return;
                }
              }
            }
          }
        }
        if (((!Objects.equal(stmt.getMeta(), null)) && (!Objects.equal(stmt.getMeta().getIfs(), null)))) {
          EList<IfSql> _ifs = stmt.getMeta().getIfs();
          for (final IfSql ifs : _ifs) {
            EList<IfSqlFragment> _sqls_1 = ifs.getSqls();
            boolean _notEquals_1 = (!Objects.equal(_sqls_1, null));
            if (_notEquals_1) {
              EList<IfSqlFragment> _sqls_2 = ifs.getSqls();
              for (final IfSqlFragment stmt2 : _sqls_2) {
                if ((((!Objects.equal(stmt2.getCol(), null)) && (!Objects.equal(stmt2.getCol().getColumns(), null))) && (!Objects.equal(stmt2.getCol().getColumns(), null)))) {
                  EList<ExtendedColumn> _columns_1 = stmt2.getCol().getColumns();
                  for (final ExtendedColumn _col_1 : _columns_1) {
                    EList<String> _modifiers_2 = _col_1.getModifiers();
                    boolean _notEquals_2 = (!Objects.equal(_modifiers_2, null));
                    if (_notEquals_2) {
                      EList<String> _modifiers_3 = _col_1.getModifiers();
                      for (final String mod_1 : _modifiers_3) {
                        int _indexOf_1 = mod_1.indexOf("gtype");
                        boolean _greaterEqualsThan_1 = (_indexOf_1 >= 0);
                        if (_greaterEqualsThan_1) {
                          this.warning((((("Problem property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
                          return;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    this.error((((("Cannot find property : " + columnName) + "[") + columnUsageClass) + "]"), column, ProcessorMetaPackage.Literals.COLUMN__COLUMNS);
  }
  
  public void checkConstant(final Constant constant, final PojoDefinition pojo, final String pojoName, final MetaStatement statement, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(constant);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    String _xifexpression = null;
    boolean _notEquals = (!Objects.equal(pojo, null));
    if (_notEquals) {
      _xifexpression = pojo.getQualifiedName();
    }
    final String constantUsageClass = _xifexpression;
    ValidationResult validationResult = null;
    boolean _notEquals_1 = (!Objects.equal(constantUsageClass, null));
    if (_notEquals_1) {
      if ((newPojoValidator && (pojo.getClassx() instanceof JvmDeclaredType))) {
        JvmType _classx = pojo.getClassx();
        validationResult = this.checkClassProperty(((JvmDeclaredType) _classx), constant.getName());
      } else {
        validationResult = this.checkClassProperty(constantUsageClass, constant.getName(), uri, descriptorsCache, classesCache);
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            String _name = constant.getName();
            String _plus = ("Problem property : " + _name);
            String _plus_1 = (_plus + "[");
            String _plus_2 = (_plus_1 + constantUsageClass);
            String _plus_3 = (_plus_2 + "]");
            this.warning(_plus_3, constant, ProcessorMetaPackage.Literals.CONSTANT__NAME);
            break;
          case ERROR:
            String _name_1 = constant.getName();
            String _plus_4 = ("Cannot find property : " + _name_1);
            String _plus_5 = (_plus_4 + "[");
            String _plus_6 = (_plus_5 + constantUsageClass);
            String _plus_7 = (_plus_6 + "]");
            this.error(_plus_7, constant, ProcessorMetaPackage.Literals.CONSTANT__NAME);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_2 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_2) {
      String _name_2 = constant.getName();
      String _plus_8 = ("Cannot check constant form attribute : " + _name_2);
      this.error(_plus_8, 
        ProcessorMetaPackage.Literals.CONSTANT__NAME);
    }
  }
  
  @Check
  public void checkMappingRule(final MappingRule rule) {
    if ((Objects.equal(rule.getModifiers(), null) || rule.getModifiers().isEmpty())) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(rule, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(rule);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    Resource _eResource = rule.eResource();
    URI _uRI = null;
    if (_eResource!=null) {
      _uRI=_eResource.getURI();
    }
    final URI uri = _uRI;
    final Map<String, PropertyDescriptor[]> descriptorsCache = new HashMap<String, PropertyDescriptor[]>();
    final Map<String, Class<?>> classesCache = new HashMap<String, Class<?>>();
    int index = 0;
    String colPojoName = null;
    PojoDefinition colPojo = null;
    EList<String> _modifiers = rule.getModifiers();
    for (final String modifier : _modifiers) {
      {
        int ix = modifier.indexOf("=");
        if ((ix > 0)) {
          final String key = modifier.substring(0, ix);
          final String value = modifier.substring((ix + 1));
          boolean _equals_1 = Constants.MAPPING_USAGE.equals(key);
          if (_equals_1) {
            colPojo = this.modelProperty.getModelPojos(artifacts).get(value);
            boolean _equals_2 = Objects.equal(colPojo, null);
            if (_equals_2) {
              this.error((((("Cannot find pojo : " + value) + "[") + Constants.MAPPING_USAGE) + "]"), 
                ProcessorMetaPackage.Literals.MAPPING_RULE__MODIFIERS, index);
            } else {
              colPojoName = value;
            }
          }
          index = (index + 1);
        }
      }
    }
    boolean _notEquals = (!Objects.equal(colPojo, null));
    if (_notEquals) {
      boolean _isOldPojoValidator = this.modelProperty.isOldPojoValidator(rule);
      final boolean newPojoValidator = (!_isOldPojoValidator);
      final List<MappingColumn> columns = EcoreUtil2.<MappingColumn>getAllContentsOfType(rule, MappingColumn.class);
      final PojoDefinition pojo = colPojo;
      final String pojoName = colPojoName;
      final Consumer<MappingColumn> _function = (MappingColumn column) -> {
        this.checkMappingColumn(column, pojo, pojoName, rule, newPojoValidator, artifacts, uri, descriptorsCache, classesCache);
      };
      columns.forEach(_function);
    }
  }
  
  public void checkMappingColumn(final MappingColumn column, final PojoDefinition pojo, final String pojoName, final MappingRule rule, final boolean newPojoValidator, final Artifacts artifacts, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    boolean _isResolvePojo = this.isResolvePojo(column);
    boolean _not = (!_isResolvePojo);
    if (_not) {
      return;
    }
    final String columnName = Utils.getName(column);
    boolean _isNumber = Utils.isNumber(columnName);
    if (_isNumber) {
      return;
    }
    final String mappingUsageClass = pojo.getQualifiedName();
    ValidationResult validationResult = null;
    boolean _notEquals = (!Objects.equal(mappingUsageClass, null));
    if (_notEquals) {
      if ((newPojoValidator && (pojo.getClassx() instanceof JvmDeclaredType))) {
        JvmType _classx = pojo.getClassx();
        validationResult = this.checkClassProperty(((JvmDeclaredType) _classx), columnName);
      } else {
        validationResult = this.checkClassProperty(mappingUsageClass, columnName, uri, descriptorsCache, classesCache);
      }
      if (validationResult != null) {
        switch (validationResult) {
          case WARNING:
            this.warning((((("Problem property : " + columnName) + "[") + mappingUsageClass) + "]"), column, ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS);
            break;
          case ERROR:
            this.error((((("Cannot find property : " + columnName) + "[") + mappingUsageClass) + "]"), column, ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS);
            break;
          default:
            break;
        }
      }
      return;
    }
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _notEquals_1 = (!Objects.equal(_pojoResolver, null));
    if (_notEquals_1) {
      this.error(("Cannot check result class attribute : " + columnName), column, ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS);
    }
  }
  
  public ValidationResult checkClassProperty(final String className, final String property, final URI uri, final Map<String, PropertyDescriptor[]> descriptorsCache, final Map<String, Class<?>> classesCache) {
    if (((Objects.equal(property, null) || Utils.isNumber(property)) || Objects.equal(this.pojoResolverFactory.getPojoResolver(), null))) {
      return ValidationResult.OK;
    }
    boolean _equals = Objects.equal(className, null);
    if (_equals) {
      return ValidationResult.ERROR;
    }
    String _string = uri.toString();
    String _plus = (_string + className);
    PropertyDescriptor[] descriptors = descriptorsCache.get(_plus);
    boolean _equals_1 = Objects.equal(descriptors, null);
    if (_equals_1) {
      descriptors = this.pojoResolverFactory.getPojoResolver().getPropertyDescriptors(className, uri);
    }
    boolean _equals_2 = Objects.equal(descriptors, null);
    if (_equals_2) {
      return ValidationResult.WARNING;
    } else {
      String _string_1 = uri.toString();
      String _plus_1 = (_string_1 + className);
      descriptorsCache.put(_plus_1, descriptors);
    }
    String checkProperty = property;
    int pos1 = checkProperty.indexOf("=");
    if ((pos1 > 0)) {
      int pos2 = checkProperty.indexOf(".", pos1);
      if ((pos2 > pos1)) {
        String _substring = checkProperty.substring(0, pos1);
        String _substring_1 = checkProperty.substring(pos2);
        String _plus_2 = (_substring + _substring_1);
        checkProperty = _plus_2;
      }
    }
    String innerProperty = ((String) null);
    pos1 = checkProperty.indexOf(".");
    if ((pos1 > 0)) {
      innerProperty = checkProperty.substring((pos1 + 1));
      checkProperty = checkProperty.substring(0, pos1);
    }
    final String _checkProperty = checkProperty;
    final PropertyDescriptor[] _converted_descriptors = (PropertyDescriptor[])descriptors;
    final Function1<PropertyDescriptor, Boolean> _function = (PropertyDescriptor descriptor) -> {
      String _name = descriptor.getName();
      return Boolean.valueOf(Objects.equal(_name, _checkProperty));
    };
    PropertyDescriptor checkDesriptor = IterableExtensions.<PropertyDescriptor>findFirst(((Iterable<PropertyDescriptor>)Conversions.doWrapArray(_converted_descriptors)), _function);
    boolean _equals_3 = Objects.equal(checkDesriptor, null);
    if (_equals_3) {
      String _string_2 = uri.toString();
      String _plus_3 = (_string_2 + className);
      Class<?> clazz = classesCache.get(_plus_3);
      boolean _equals_4 = Objects.equal(clazz, null);
      if (_equals_4) {
        clazz = this.pojoResolverFactory.getPojoResolver().loadClass(className, uri);
      }
      if (((!Objects.equal(clazz, null)) && Modifier.isAbstract(clazz.getModifiers()))) {
        return ValidationResult.WARNING;
      }
      if (((!Objects.equal(clazz, null)) && this.isPrimitive(clazz))) {
        return ValidationResult.OK;
      }
      return ValidationResult.ERROR;
    }
    boolean _notEquals = (!Objects.equal(innerProperty, null));
    if (_notEquals) {
      Class<?> innerClass = checkDesriptor.getPropertyType();
      boolean _isArray = innerClass.isArray();
      if (_isArray) {
        Type _genericReturnType = checkDesriptor.getReadMethod().getGenericReturnType();
        final ParameterizedType type = ((ParameterizedType) _genericReturnType);
        if ((Objects.equal(type.getActualTypeArguments(), null) || (type.getActualTypeArguments().length == 0))) {
          return ValidationResult.WARNING;
        }
        Type _head = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(type.getActualTypeArguments())));
        innerClass = ((Class<?>) _head);
        boolean _isPrimitive = this.isPrimitive(innerClass);
        if (_isPrimitive) {
          return ValidationResult.ERROR;
        }
        return this.checkClassProperty(innerClass.getName(), innerProperty, uri, descriptorsCache, classesCache);
      } else {
        boolean _isAssignableFrom = Collection.class.isAssignableFrom(innerClass);
        if (_isAssignableFrom) {
          Type _genericReturnType_1 = checkDesriptor.getReadMethod().getGenericReturnType();
          final ParameterizedType type_1 = ((ParameterizedType) _genericReturnType_1);
          if ((Objects.equal(type_1.getActualTypeArguments(), null) || (type_1.getActualTypeArguments().length == 0))) {
            return ValidationResult.WARNING;
          }
          Type _head_1 = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(type_1.getActualTypeArguments())));
          innerClass = ((Class<?>) _head_1);
          boolean _isPrimitive_1 = this.isPrimitive(innerClass);
          if (_isPrimitive_1) {
            return ValidationResult.ERROR;
          }
          return this.checkClassProperty(innerClass.getName(), innerProperty, uri, descriptorsCache, classesCache);
        } else {
          boolean _isPrimitive_2 = this.isPrimitive(innerClass);
          if (_isPrimitive_2) {
            return ValidationResult.ERROR;
          }
          return this.checkClassProperty(innerClass.getName(), innerProperty, uri, descriptorsCache, classesCache);
        }
      }
    }
    return ValidationResult.OK;
  }
  
  public ValidationResult checkClassProperty(final JvmDeclaredType jvmType, final String property) {
    if ((Objects.equal(property, null) || Utils.isNumber(property))) {
      return ValidationResult.OK;
    }
    boolean _equals = Objects.equal(jvmType, null);
    if (_equals) {
      return ValidationResult.ERROR;
    }
    String checkProperty = property;
    int pos1 = checkProperty.indexOf("=");
    if ((pos1 > 0)) {
      int pos2 = checkProperty.indexOf(".", pos1);
      if ((pos2 > pos1)) {
        String _substring = checkProperty.substring(0, pos1);
        String _substring_1 = checkProperty.substring(pos2);
        String _plus = (_substring + _substring_1);
        checkProperty = _plus;
      }
    }
    String innerProperty = ((String) null);
    pos1 = checkProperty.indexOf(".");
    if ((pos1 > 0)) {
      innerProperty = checkProperty.substring((pos1 + 1));
      checkProperty = checkProperty.substring(0, pos1);
    }
    Iterable<JvmFeature> features = jvmType.findAllFeaturesByName(checkProperty);
    if (((Objects.equal(features, null) || IterableExtensions.isEmpty(features)) || (!(IterableExtensions.<JvmFeature>head(features) instanceof JvmField)))) {
      String _firstUpper = StringExtensions.toFirstUpper(checkProperty);
      String _plus_1 = ("get" + _firstUpper);
      features = jvmType.findAllFeaturesByName(_plus_1);
    }
    if (((Objects.equal(features, null) || IterableExtensions.isEmpty(features)) || ((!(IterableExtensions.<JvmFeature>head(features) instanceof JvmOperation)) && (!(IterableExtensions.<JvmFeature>head(features) instanceof JvmField))))) {
      if (((jvmType instanceof JvmPrimitiveType) || this.isPrimitive(jvmType.getQualifiedName()))) {
        return ValidationResult.OK;
      }
      boolean _isAbstract = jvmType.isAbstract();
      if (_isAbstract) {
        return ValidationResult.WARNING;
      }
      return ValidationResult.ERROR;
    }
    boolean _notEquals = (!Objects.equal(innerProperty, null));
    if (_notEquals) {
      JvmFeature _head = IterableExtensions.<JvmFeature>head(features);
      if ((_head instanceof JvmOperation)) {
        return ValidationResult.ERROR;
      }
      JvmFeature _head_1 = IterableExtensions.<JvmFeature>head(features);
      JvmField field = ((JvmField) _head_1);
      JvmTypeReference _type = field.getType();
      if ((_type instanceof JvmParameterizedTypeReference)) {
        JvmTypeReference _type_1 = field.getType();
        final JvmType type = ((JvmParameterizedTypeReference) _type_1).getType();
        if ((!(type instanceof JvmDeclaredType))) {
          InputOutput.<String>print((("checkClassProperty " + property) + ": "));
          InputOutput.<JvmType>println(type);
        } else {
          JvmTypeReference _type_2 = field.getType();
          final List<JvmTypeReference> typeArgs = ((JvmParameterizedTypeReference) _type_2).getArguments();
          if ((((!Objects.equal(typeArgs, null)) && (!typeArgs.isEmpty())) && (IterableExtensions.<JvmTypeReference>head(typeArgs) instanceof JvmParameterizedTypeReference))) {
            JvmTypeReference _head_2 = IterableExtensions.<JvmTypeReference>head(typeArgs);
            final JvmType type2 = ((JvmParameterizedTypeReference) _head_2).getType();
            if ((!(type2 instanceof JvmDeclaredType))) {
              InputOutput.<String>print((("checkClassProperty2 " + property) + ": "));
              InputOutput.<JvmType>println(type2);
            } else {
              return this.checkClassProperty(((JvmDeclaredType) type2), innerProperty);
            }
          } else {
            return this.checkClassProperty(((JvmDeclaredType) type), innerProperty);
          }
        }
      }
      return ValidationResult.WARNING;
    }
    return ValidationResult.OK;
  }
  
  public Set<String> getFieldNamesForClass(final JvmDeclaredType jvmType) {
    final Set<String> result = CollectionLiterals.<String>newHashSet();
    Iterable<JvmField> _declaredFields = jvmType.getDeclaredFields();
    for (final JvmField field : _declaredFields) {
      result.add(field.getSimpleName());
    }
    return result;
  }
  
  public ValidationResult checkOrderProperty(final String className, final String property, final URI uri, final Map<String, Map<String, String>> ordersCache, final Map<String, Class<?>> classesCache) {
    if ((Objects.equal(property, null) || Objects.equal(this.pojoResolverFactory.getPojoResolver(), null))) {
      return ValidationResult.OK;
    }
    boolean _equals = Objects.equal(className, null);
    if (_equals) {
      return ValidationResult.ERROR;
    }
    String _string = uri.toString();
    String _plus = (_string + className);
    Map<String, String> orders = ordersCache.get(_plus);
    boolean _equals_1 = Objects.equal(orders, null);
    if (_equals_1) {
      orders = this.pojoResolverFactory.getPojoResolver().getOrders(className, uri);
    }
    boolean _equals_2 = Objects.equal(orders, null);
    if (_equals_2) {
      return ValidationResult.WARNING;
    } else {
      String _string_1 = uri.toString();
      String _plus_1 = (_string_1 + className);
      ordersCache.put(_plus_1, orders);
    }
    final Map<String, String> _orders = orders;
    final Function1<String, Boolean> _function = (String k) -> {
      return Boolean.valueOf(_orders.get(k).equals(property));
    };
    final String order = IterableExtensions.<String>findFirst(orders.keySet(), _function);
    boolean _notEquals = (!Objects.equal(order, null));
    if (_notEquals) {
      return ValidationResult.OK;
    } else {
      return ValidationResult.ERROR;
    }
  }
  
  public ValidationResult checkOrderProperty(final JvmDeclaredType jvmType, final String property) {
    boolean _equals = Objects.equal(property, null);
    if (_equals) {
      return ValidationResult.OK;
    }
    boolean _equals_1 = Objects.equal(jvmType, null);
    if (_equals_1) {
      return ValidationResult.ERROR;
    }
    final Iterable<JvmFeature> features = jvmType.findAllFeaturesByName(("ORDER_BY_" + property));
    if (((Objects.equal(features, null) || IterableExtensions.isEmpty(features)) || (!(IterableExtensions.<JvmFeature>head(features) instanceof JvmField)))) {
      final Iterable<JvmDeclaredType> nestedTypes = jvmType.findAllNestedTypesByName("Order");
      if (((Objects.equal(nestedTypes, null) || IterableExtensions.isEmpty(nestedTypes)) || (!(IterableExtensions.<JvmDeclaredType>head(nestedTypes) instanceof JvmEnumerationType)))) {
        return ValidationResult.ERROR;
      }
      JvmDeclaredType _head = IterableExtensions.<JvmDeclaredType>head(nestedTypes);
      final JvmEnumerationType type = ((JvmEnumerationType) _head);
      final Iterable<JvmFeature> features2 = type.findAllFeaturesByName(property);
      if (((Objects.equal(features2, null) || IterableExtensions.isEmpty(features2)) || (!(IterableExtensions.<JvmFeature>head(features2) instanceof JvmEnumerationLiteral)))) {
        return ValidationResult.ERROR;
      }
    }
    return ValidationResult.OK;
  }
  
  @Check
  public void checkTableDefinition(final TableDefinitionModel tableDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(tableDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(tableDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<TableDefinitionModel> _tables = artifacts.getTables();
    for (final TableDefinitionModel table : _tables) {
      if (((!Objects.equal(table, null)) && (table != tableDefinition))) {
        boolean _equals_1 = tableDefinition.getName().equals(table.getName());
        if (_equals_1) {
          String _name = tableDefinition.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[table]");
          this.error(_plus_1, 
            ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
    if ((this.isResolveDb(tableDefinition) && (!this.dbResolver.checkTable(tableDefinition, tableDefinition.getTable())))) {
      String _table = tableDefinition.getTable();
      String _plus_2 = ("Cannot find table in DB : " + _table);
      this.error(_plus_2, 
        ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__TABLE);
    }
  }
  
  @Check
  public void checkProcedureDefinition(final ProcedureDefinitionModel procedureDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(procedureDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(procedureDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<ProcedureDefinitionModel> _procedures = artifacts.getProcedures();
    for (final ProcedureDefinitionModel procedure : _procedures) {
      if (((!Objects.equal(procedure, null)) && (procedure != procedureDefinition))) {
        boolean _equals_1 = procedureDefinition.getName().equals(procedure.getName());
        if (_equals_1) {
          String _name = procedureDefinition.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[procedure]");
          this.error(_plus_1, 
            ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
    if ((this.isResolveDb(procedureDefinition) && (!this.dbResolver.checkProcedure(procedureDefinition, procedureDefinition.getTable())))) {
      String _table = procedureDefinition.getTable();
      String _plus_2 = ("Cannot find procedure in DB : " + _table);
      this.error(_plus_2, 
        ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME);
    }
  }
  
  @Check
  public void checkFunctionDefinition(final FunctionDefinitionModel functionDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(functionDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(functionDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<FunctionDefinitionModel> _functions = artifacts.getFunctions();
    for (final FunctionDefinitionModel function : _functions) {
      if (((!Objects.equal(function, null)) && (function != functionDefinition))) {
        boolean _equals_1 = functionDefinition.getName().equals(function.getName());
        if (_equals_1) {
          String _name = functionDefinition.getName();
          String _plus = ("Duplicate name : " + _name);
          String _plus_1 = (_plus + "[function]");
          this.error(_plus_1, 
            ProcessorMetaPackage.Literals.FUNCTION_DEFINITION_MODEL__NAME);
          return;
        }
      }
    }
  }
  
  public void _checkDatabaseTable(final DatabaseTable databaseTable) {
    boolean _isResolveDb = this.isResolveDb(databaseTable);
    boolean _not = (!_isResolveDb);
    if (_not) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(databaseTable, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final MetaStatement statement = EcoreUtil2.<MetaStatement>getContainerOfType(databaseTable, MetaStatement.class);
    final Artifacts artifacts = this.getArtifacts(statement);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    final String tableName = databaseTable.getName();
    final Function1<String, TableDefinition> _function = (String value) -> {
      return this.modelProperty.getModelTables(artifacts).get(value);
    };
    final List<TableDefinition> tableDefinitions = ListExtensions.<String, TableDefinition>map(Utils.getTokensFromModifier(statement, Constants.TABLE_USAGE), _function);
    final Function1<TableDefinition, Boolean> _function_1 = (TableDefinition it) -> {
      String _table = it.getTable();
      return Boolean.valueOf(Objects.equal(_table, tableName));
    };
    final TableDefinition tableDefinition = IterableExtensions.<TableDefinition>findFirst(tableDefinitions, _function_1);
    if ((Objects.equal(tableDefinition, null) || (!this.dbResolver.checkTable(databaseTable, tableName)))) {
      this.error(("Cannot find table in DB : " + tableName), ProcessorMetaPackage.Literals.DATABASE_TABLE__NAME);
    }
  }
  
  public void _checkDatabaseColumn(final DatabaseColumn databaseColumn) {
    boolean _isResolveDb = this.isResolveDb(databaseColumn);
    boolean _not = (!_isResolveDb);
    if (_not) {
      return;
    }
    boolean _skipVerification = CommonUtils.skipVerification(databaseColumn, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    String prefix = databaseColumn.getName();
    String columnName = ((String) null);
    final int pos = prefix.indexOf(".");
    if ((pos > 0)) {
      prefix = databaseColumn.getName().substring(0, pos);
      columnName = databaseColumn.getName().substring((pos + 1));
    } else {
      prefix = null;
      columnName = databaseColumn.getName();
    }
    final MetaStatement statement = EcoreUtil2.<MetaStatement>getContainerOfType(databaseColumn, MetaStatement.class);
    final Artifacts artifacts = this.getArtifacts(statement);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    final String value = Utils.getTokenFromModifier(statement, Constants.TABLE_USAGE, prefix);
    TableDefinition _xifexpression = null;
    boolean _notEquals = (!Objects.equal(value, null));
    if (_notEquals) {
      _xifexpression = this.modelProperty.getModelTables(artifacts).get(value);
    }
    final TableDefinition tableDefinition = _xifexpression;
    String _xifexpression_1 = null;
    boolean _notEquals_1 = (!Objects.equal(tableDefinition, null));
    if (_notEquals_1) {
      _xifexpression_1 = tableDefinition.getTable();
    }
    final String tableName = _xifexpression_1;
    if ((Objects.equal(tableName, null) || (!this.dbResolver.checkColumn(databaseColumn, tableName, columnName)))) {
      String _name = databaseColumn.getName();
      String _plus = ("Cannot find column in DB : " + _name);
      String _plus_1 = (_plus + "[");
      String _plus_2 = (_plus_1 + tableName);
      String _plus_3 = (_plus_2 + "]");
      this.error(_plus_3, 
        ProcessorMetaPackage.Literals.DATABASE_COLUMN__NAME);
    }
  }
  
  public Artifacts getArtifacts(final EObject model) {
    final EObject root = EcoreUtil.getRootContainer(model);
    if ((!(root instanceof Artifacts))) {
      return null;
    }
    return ((Artifacts) root);
  }
  
  public boolean isPrimitive(final Class<?> clazz) {
    boolean _equals = Objects.equal(clazz, null);
    if (_equals) {
      return true;
    }
    boolean _equals_1 = Objects.equal(clazz, String.class);
    if (_equals_1) {
      return true;
    }
    boolean _equals_2 = Objects.equal(clazz, Byte.class);
    if (_equals_2) {
      return true;
    }
    boolean _equals_3 = Objects.equal(clazz, Short.class);
    if (_equals_3) {
      return true;
    }
    boolean _equals_4 = Objects.equal(clazz, Integer.class);
    if (_equals_4) {
      return true;
    }
    boolean _equals_5 = Objects.equal(clazz, Long.class);
    if (_equals_5) {
      return true;
    }
    boolean _equals_6 = Objects.equal(clazz, Double.class);
    if (_equals_6) {
      return true;
    }
    boolean _equals_7 = Objects.equal(clazz, Float.class);
    if (_equals_7) {
      return true;
    }
    boolean _equals_8 = Objects.equal(clazz, Boolean.class);
    if (_equals_8) {
      return true;
    }
    boolean _equals_9 = Objects.equal(clazz, Date.class);
    if (_equals_9) {
      return true;
    }
    boolean _equals_10 = Objects.equal(clazz, java.sql.Date.class);
    if (_equals_10) {
      return true;
    }
    boolean _equals_11 = Objects.equal(clazz, Time.class);
    if (_equals_11) {
      return true;
    }
    boolean _equals_12 = Objects.equal(clazz, Timestamp.class);
    if (_equals_12) {
      return true;
    }
    boolean _equals_13 = Objects.equal(clazz, Blob.class);
    if (_equals_13) {
      return true;
    }
    boolean _equals_14 = Objects.equal(clazz, Clob.class);
    if (_equals_14) {
      return true;
    }
    boolean _equals_15 = Objects.equal(clazz, BigDecimal.class);
    if (_equals_15) {
      return true;
    }
    boolean _equals_16 = Objects.equal(clazz, BigInteger.class);
    if (_equals_16) {
      return true;
    }
    return false;
  }
  
  public boolean isPrimitive(final String name) {
    boolean _equals = Objects.equal(name, null);
    if (_equals) {
      return true;
    }
    boolean _equals_1 = Objects.equal(name, "java.lang.String");
    if (_equals_1) {
      return true;
    }
    boolean _equals_2 = Objects.equal(name, "java.lang.Byte");
    if (_equals_2) {
      return true;
    }
    boolean _equals_3 = Objects.equal(name, "java.lang.Short");
    if (_equals_3) {
      return true;
    }
    boolean _equals_4 = Objects.equal(name, "java.lang.Integer");
    if (_equals_4) {
      return true;
    }
    boolean _equals_5 = Objects.equal(name, "java.lang.Long");
    if (_equals_5) {
      return true;
    }
    boolean _equals_6 = Objects.equal(name, "java.lang.Double");
    if (_equals_6) {
      return true;
    }
    boolean _equals_7 = Objects.equal(name, "java.lang.Float");
    if (_equals_7) {
      return true;
    }
    boolean _equals_8 = Objects.equal(name, "java.lang.Boolean");
    if (_equals_8) {
      return true;
    }
    boolean _equals_9 = Objects.equal(name, "java.util.Date");
    if (_equals_9) {
      return true;
    }
    boolean _equals_10 = Objects.equal(name, "java.sql.Date");
    if (_equals_10) {
      return true;
    }
    boolean _equals_11 = Objects.equal(name, "java.sql.Time");
    if (_equals_11) {
      return true;
    }
    boolean _equals_12 = Objects.equal(name, "java.sql.Timestamp");
    if (_equals_12) {
      return true;
    }
    boolean _equals_13 = Objects.equal(name, "java.sql.Blob");
    if (_equals_13) {
      return true;
    }
    boolean _equals_14 = Objects.equal(name, "java.sql.Clob");
    if (_equals_14) {
      return true;
    }
    boolean _equals_15 = Objects.equal(name, "java.math.BigDecimal");
    if (_equals_15) {
      return true;
    }
    boolean _equals_16 = Objects.equal(name, "java.math.BigInteger");
    if (_equals_16) {
      return true;
    }
    return false;
  }
  
  public boolean isResolvePojo(final EObject model) {
    return this.modelProperty.isDoResolvePojo(model);
  }
  
  public boolean isResolveDb(final EObject model) {
    return this.dbResolver.isResolveDb(model);
  }
}
