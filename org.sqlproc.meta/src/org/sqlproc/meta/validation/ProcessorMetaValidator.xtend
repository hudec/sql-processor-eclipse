/*
 * generated by Xtext
 */
package org.sqlproc.meta.validation
import org.eclipse.xtext.validation.Check

import static org.sqlproc.plugin.lib.util.Constants.*

import java.lang.reflect.Modifier
import java.lang.reflect.ParameterizedType
import java.util.Collection
import java.util.List

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.scoping.IScopeProvider
import org.sqlproc.meta.processorMeta.Artifacts
import org.sqlproc.meta.processorMeta.Column
import org.sqlproc.meta.processorMeta.Constant
import org.sqlproc.meta.processorMeta.DatabaseColumn
import org.sqlproc.meta.processorMeta.DatabaseTable
import org.sqlproc.meta.processorMeta.FunctionDefinitionModel
import org.sqlproc.meta.processorMeta.Identifier
import org.sqlproc.meta.processorMeta.MappingColumn
import org.sqlproc.meta.processorMeta.MappingRule
import org.sqlproc.meta.processorMeta.MetaSql
import org.sqlproc.meta.processorMeta.MetaStatement
import org.sqlproc.meta.processorMeta.OptionalFeature
import org.sqlproc.meta.processorMeta.PojoDefinitionModel
import org.sqlproc.meta.processorMeta.ProcedureDefinitionModel
import org.sqlproc.meta.processorMeta.ProcessorMetaPackage
import org.sqlproc.meta.processorMeta.Property
import org.sqlproc.meta.processorMeta.TableDefinitionModel
import org.sqlproc.meta.util.Utils

import com.google.inject.Inject

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import org.eclipse.emf.common.util.URI
import org.sqlproc.plugin.lib.resolver.PojoResolverFactory
import org.sqlproc.plugin.lib.resolver.DbResolver
import org.sqlproc.plugin.lib.property.ModelProperty
import org.sqlproc.plugin.lib.util.CommonUtils

enum ValidationResult {
	OK, WARNING, ERROR
}

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ProcessorMetaValidator extends AbstractProcessorMetaValidator {

    @Inject
    PojoResolverFactory pojoResolverFactory

    @Inject
    DbResolver dbResolver

    @Inject
    IScopeProvider scopeProvider

    @Inject
    IQualifiedNameConverter qualifiedNameConverter

    @Inject
    ModelProperty modelProperty


    val F_TYPES = <String>newArrayList("set", "update", "values", "where", "columns", "set=opt", "where=opt")

    @Check
    def checkMetaSqlFtype(MetaSql metaSql) {
        if (metaSql.getFtype() == null)
            return;
        if (CommonUtils.skipVerification(metaSql, modelProperty))
            return;
            
        if (!findInListIgnoreCase(F_TYPES, metaSql.getFtype())) {
            error("Invalid ftype : " + metaSql.getFtype(), ProcessorMetaPackage.Literals.META_SQL__FTYPE)
        }
    }

    def findInListIgnoreCase(List<String> list, String value) {
        if (list == null)
            return false
        for (String item : list) {
            if (item.equalsIgnoreCase(value))
                return true
        }
        return false
    }
    
    @Check
    def checkUniqueMetaStatement(MetaStatement metaStatement) {
        if (CommonUtils.skipVerification(metaStatement, modelProperty))
            return;
        val artifacts = getArtifacts(metaStatement)
        if (artifacts == null)
            return;

        for (MetaStatement metaStmt : artifacts.getStatements()) {
            if (metaStmt != null && metaStmt !== metaStatement) {
	            if (equalsStatement(metaStatement, metaStmt)) {
	                error("Duplicate name : " + metaStatement.getName() + "[" + metaStatement.getType() + "]",
	                        ProcessorMetaPackage.Literals.META_STATEMENT__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkUniqueMappingRule(MappingRule mappingRule) {
        if (CommonUtils.skipVerification(mappingRule, modelProperty))
            return;
        val artifacts = getArtifacts(mappingRule)
        if (artifacts == null)
            return;

        for (MappingRule rule : artifacts.getMappings()) {
            if (rule != null && rule !== mappingRule) {
	            if (equalsRule(mappingRule, rule)) {
	                error("Duplicate name : " + mappingRule.getName() + "[" + mappingRule.getType() + "]",
	                        ProcessorMetaPackage.Literals.MAPPING_RULE__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkUniqueOptionalFeature(OptionalFeature optionalFeature) {
        if (CommonUtils.skipVerification(optionalFeature, modelProperty))
            return;
        val artifacts = getArtifacts(optionalFeature)
        if (artifacts == null)
            return;

        for (OptionalFeature feature : artifacts.getFeatures()) {
            if (feature != null && feature != optionalFeature) {
	            if (equalsFeature(optionalFeature, feature)) {
	                error("Duplicate name : " + optionalFeature.getName() + "[" + optionalFeature.getType() + "]",
	                        ProcessorMetaPackage.Literals.OPTIONAL_FEATURE__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkUniquePojoDefinition(PojoDefinitionModel pojoDefinition) {
        if (CommonUtils.skipVerification(pojoDefinition, modelProperty))
            return;
        val artifacts = getArtifacts(pojoDefinition)
        if (artifacts == null)
            return;
            
    	val URI uri = pojoDefinition.eResource?.URI
        if (isResolvePojo(pojoDefinition) && !checkClass(getClass(pojoDefinition), uri))
            error("Class name : " + getClass(pojoDefinition) + " not exists",
                    ProcessorMetaPackage.Literals.POJO_DEFINITION_MODEL__NAME)
        for (PojoDefinitionModel definition : artifacts.getPojos()) {
            if (definition != null && definition !== pojoDefinition) {
	            if (pojoDefinition.getName().equals(definition.getName())) {
	                error("Duplicate name : " + pojoDefinition.getName(),
	                        ProcessorMetaPackage.Literals.POJO_DEFINITION_MODEL__NAME)
	                return
	            }
            }
        }
    }


    def equalsStatement(MetaStatement statement1, MetaStatement statement2) {
        if (statement1 == null && statement2 == null)
            return true
        if (statement1 == null || statement1.getName() == null)
            return false
        if (statement2 == null || statement2.getName() == null)
            return false
        if (statement1.getName().equals(statement2.getName()) && statement1.getType().equals(statement2.getType())) {
            return equalsModifiers(statement1.getModifiers(), statement2.getModifiers())
        }
        return false
    }

    def equalsRule(MappingRule rule1, MappingRule rule2) {
        if (rule1 == null && rule2 == null)
            return true
        if (rule1 == null || rule1.getName() == null)
            return false
        if (rule2 == null || rule2.getName() == null)
            return false
        if (rule1.getName().equals(rule2.getName()) && rule1.getType().equals(rule2.getType())) {
            return equalsModifiers(rule1.getModifiers(), rule2.getModifiers())
        }
        return false
    }

    def equalsFeature(OptionalFeature feature1, OptionalFeature feature2) {
        if (feature1 == null && feature2 == null)
            return true
        if (feature1 == null || feature1.getName() == null)
            return false
        if (feature2 == null || feature2.getName() == null)
            return false
        if (feature1.getName().equals(feature2.getName()) && feature1.getType().equals(feature2.getType())) {
            return equalsModifiers(feature1.getModifiers(), feature2.getModifiers())
        }
        return false
    }

    def equalsModifiers(List<String> modifiers1, List<String> modifiers2) {
        val filteredModifiers1 = filteredModifiers(modifiers1)
        val filteredModifiers2 = filteredModifiers(modifiers2)
        if (filteredModifiers1 == null && filteredModifiers2 == null)
            return true
        if (filteredModifiers1 == null)
            return false
        if (filteredModifiers2 == null)
            return false
        if (filteredModifiers1.isEmpty() && filteredModifiers2.isEmpty())
            return true
        // Filtry musi byt disjunktni, pro jednu shodu je vysledek komparace kladny
        for (String modifier1 : filteredModifiers1)
            for (String modifier2 : filteredModifiers2)
                if (modifier1.equals(modifier2))
                    return true
        return false
    }

    def List<String> filteredModifiers(List<String> modifiers) {
        if (modifiers == null)
            return null
        val filteredModifiers = <String>newArrayList()
        modifiers.forEach[modifier |
            if (modifier.indexOf('=') < 0)
                filteredModifiers.add(modifier)
        ]
        return filteredModifiers
    }

    def checkClass(String className, URI uri) {
        if (className == null || pojoResolverFactory.getPojoResolver() == null)
            return true

        val clazz = pojoResolverFactory.getPojoResolver().loadClass(className, uri)
        return clazz != null
    }

    def isResolvePojo(EObject model) {
        if (pojoResolverFactory.getPojoResolver() == null
                || !pojoResolverFactory.getPojoResolver().isResolvePojo(model))
            return false
        return true

    }

    def isResolveDb(EObject model) {
        return dbResolver.isResolveDb(model)
    }

    def String getClass(PojoDefinitionModel pojo) {
        if (pojo.getClassx() != null)
            return pojo.getClassx().getQualifiedName()
        return pojo.getClass_()
    }

    @Check
    def checkColumn(Column column) {
        if (!isResolvePojo(column))
            return;
        val columnName = Utils.getName(column)
        if (Utils.isNumber(columnName))
            return;
        if (CommonUtils.skipVerification(column, modelProperty))
            return;

        val URI uri = column.eResource?.URI
        val statement = column.getContainerOfType(typeof(MetaStatement))
        val artifacts = getArtifacts(statement)
        if (artifacts == null)
            return;

        val pojoName = Utils.getTokenFromModifier(statement, COLUMN_USAGE)
        val pojo = if (pojoName != null) modelProperty.getModelPojos(artifacts).get(pojoName)
        val columnUsageClass = if (pojo != null) pojo.qualifiedName
        if (columnUsageClass != null) {
            switch (checkClassProperty(columnUsageClass, columnName, uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + columnName + "[" + columnUsageClass + "]",
                        ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
            case ValidationResult.ERROR:
            	checkColumnGType(statement, columnName, columnUsageClass)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check result class attribute : " + columnName, ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
        }
    }
    
    def checkColumnGType(MetaStatement statement, String columnName, String columnUsageClass) {
    	if (statement == null || statement.statement == null || statement.statement.sqls == null)
    		return;
    	for (stmt : statement.statement.sqls) {
    		if (stmt.col != null && stmt.col.columns != null && stmt.col.columns != null) {
				for (_col : stmt.col.columns) {
					if (_col.modifiers != null) {
						for (mod : _col.modifiers) {
							if (mod.indexOf('gtype') >= 0) {
				                warning("Problem property : " + columnName + "[" + columnUsageClass + "]",
                			        ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
                			    return
							}
						}
					}
				}
    		}
    		if (stmt.meta != null && stmt.meta.ifs != null) {
    			for (ifs : stmt.meta.ifs) {
    				if (ifs.sqls != null) {
				    	for (stmt2 : ifs.sqls) {
				    		if (stmt2.col != null && stmt2.col.columns != null && stmt2.col.columns != null) {
								for (_col : stmt2.col.columns) {
									if (_col.modifiers != null) {
										for (mod : _col.modifiers) {
											if (mod.indexOf('gtype') >= 0) {
								                warning("Problem property : " + columnName + "[" + columnUsageClass + "]",
                			    				    ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
                			    				return
											}
										}
									}
								}
				    		}
			    		}
    				}
    			}
    		}
    	}
		error("Cannot find property : " + columnName + "[" + columnUsageClass + "]",
        	ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
    }

    @Check
    def checkIdentifier(Identifier identifier) {
        if (!isResolvePojo(identifier))
            return;
        if (CommonUtils.skipVerification(identifier, modelProperty))
            return;

        val URI uri = identifier.eResource?.URI
        val identifierName = identifier.getName()
        val statement = identifier.getContainerOfType(typeof(MetaStatement))
        val artifacts = getArtifacts(statement)
        if (artifacts == null)
            return;

        val pojoName = Utils.getTokenFromModifier(statement, IDENTIFIER_USAGE)
        val pojo = if (pojoName != null) modelProperty.getModelPojos(artifacts).get(pojoName)
        val identifierUsageClass = if (pojo != null) pojo.qualifiedName
        if (identifierUsageClass != null) {
            switch (checkClassProperty(identifierUsageClass, identifierName, uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + identifierName + "[" + identifierUsageClass + "]",
                        ProcessorMetaPackage.Literals.IDENTIFIER__NAME)
            case ValidationResult.ERROR:
		        error("Cannot find property : " + identifierName + "[" + identifierUsageClass + "]",
					ProcessorMetaPackage.Literals.IDENTIFIER__NAME)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check input form attribute : " + identifierName,
                    ProcessorMetaPackage.Literals.IDENTIFIER__NAME)
        }
    }
    
    @Check
    def checkConstant(Constant constant) {
        if (!isResolvePojo(constant))
            return;
        if (CommonUtils.skipVerification(constant, modelProperty))
            return;

        val URI uri = constant.eResource?.URI
        val statement = constant.getContainerOfType(typeof(MetaStatement))
        val artifacts = getArtifacts(constant)
        if (artifacts == null)
            return;

        val pojoName = Utils.getTokenFromModifier(statement, CONSTANT_USAGE)
        val pojo = if (pojoName != null) modelProperty.getModelPojos(artifacts).get(pojoName)
        val constantUsageClass = if (pojo != null) pojo.qualifiedName
        if (constantUsageClass != null) {
            switch (checkClassProperty(constantUsageClass, constant.getName(),uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + constant.getName() + "[" + constantUsageClass + "]",
                        ProcessorMetaPackage.Literals.CONSTANT__NAME)
            case ValidationResult.ERROR:
                error("Cannot find property : " + constant.getName() + "[" + constantUsageClass + "]",
                        ProcessorMetaPackage.Literals.CONSTANT__NAME)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check constant form attribute : " + constant.getName(),
                    ProcessorMetaPackage.Literals.CONSTANT__NAME)
        }
    }

    @Check
    def checkMappingColumn(MappingColumn column) {
        if (!isResolvePojo(column))
            return;
        val columnName = Utils.getName(column)
        if (Utils.isNumber(columnName))
            return;
        if (CommonUtils.skipVerification(column, modelProperty))
            return;

        val URI uri = column.eResource?.URI
        val rule = column.getContainerOfType(typeof(MetaStatement))
        val artifacts = getArtifacts(rule)
        if (artifacts == null)
            return;

        val pojoName = Utils.getTokenFromModifier(rule, MAPPING_USAGE)
        val pojo = if (pojoName != null) modelProperty.getModelPojos(artifacts).get(pojoName)
        val mappingUsageClass = if (pojo != null) pojo.qualifiedName
        if (mappingUsageClass != null) {
            switch (checkClassProperty(mappingUsageClass, columnName, uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + columnName + "[" + mappingUsageClass + "]",
                        ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS)
            case ValidationResult.ERROR:
				error("Cannot find property : " + columnName + "[" + mappingUsageClass + "]",
        			ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check result class attribute : " + columnName,
                    ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS)
        }
    }

    @Check
    def checkMetaStatement(MetaStatement statement) {
        if (statement.getModifiers() == null || statement.getModifiers().isEmpty())
            return;
        if (CommonUtils.skipVerification(statement, modelProperty))
            return;
        val artifacts = getArtifacts(statement)
        if (artifacts == null)
            return;

        var index = 0
        for (String modifier : statement.getModifiers()) {
            var ix = modifier.indexOf('=')
            if (ix > 0) {
	            val key = modifier.substring(0, ix)
	            var value = modifier.substring(ix + 1)
	            if (IDENTIFIER_USAGE.equals(key)) {
	                val pojo = modelProperty.getModelPojos(artifacts).get(value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + IDENTIFIER_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            } else if (COLUMN_USAGE.equals(key)) {
	                val pojo = modelProperty.getModelPojos(artifacts).get(value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + COLUMN_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            } else if (CONSTANT_USAGE.equals(key)) {
	                val pojo = modelProperty.getModelPojos(artifacts).get(value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + CONSTANT_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            } else if (TABLE_USAGE.equals(key)) {
	                var ix1 = value.indexOf('=')
	                if (ix1 >= 0)
	                    value = value.substring(0, ix1)
	                val table = modelProperty.getModelTables(artifacts).get(value)
	                if (table == null) {
	                    error("Cannot find table : " + value + "[" + TABLE_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            }
	            index = index + 1
            }
        }
    }

    @Check
    def checkMappingRule(MappingRule rule) {
        if (rule.getModifiers() == null || rule.getModifiers().isEmpty())
            return;
        if (CommonUtils.skipVerification(rule, modelProperty))
            return;
        val artifacts = getArtifacts(rule)
        if (artifacts == null)
            return;

        var index = 0
        for (String modifier : rule.getModifiers()) {
            var ix = modifier.indexOf('=')
            if (ix > 0) {
	            val key = modifier.substring(0, ix)
	            val value = modifier.substring(ix + 1)
	            if (MAPPING_USAGE.equals(key)) {
	            	val pojo = modelProperty.getModelPojos(artifacts).get(value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + MAPPING_USAGE + "]",
	                            ProcessorMetaPackage.Literals.MAPPING_RULE__MODIFIERS, index)
	                }
	            }
	            index = index + 1
	        }
        }
    }

    def isNumber(String param) {
        if (param == null)
            return false
        var i = param.length() - 1
        while(i >= 0) {
            if (!Character.isDigit(param.charAt(i)))
                return false
            i = i - 1
        }
        return true
    }

    def isPrimitive(Class<?> clazz) {
        if (clazz == null)
            return true
        if (clazz == typeof(String))
            return true
        if (clazz == typeof(java.util.Date))
            return true
        if (clazz == typeof(java.sql.Date))
            return true
        if (clazz == typeof(java.sql.Time))
            return true
        if (clazz == typeof(java.sql.Timestamp))
            return true
        if (clazz == typeof(java.sql.Blob))
            return true
        if (clazz == typeof(java.sql.Clob))
            return true
        if (clazz == typeof(java.math.BigDecimal))
            return true
        if (clazz == typeof(java.math.BigInteger))
            return true
        return false
    }

    def ValidationResult checkClassProperty(String className, String property, URI uri) {
        if (property == null || isNumber(property) || pojoResolverFactory.getPojoResolver() == null)
            return ValidationResult.OK
        if (className == null)
            return ValidationResult.ERROR
        var descriptors = pojoResolverFactory.getPojoResolver().getPropertyDescriptors(className, uri)
        if (descriptors == null) {
            return ValidationResult.WARNING
        }
        var checkProperty = property
        var pos1 = checkProperty.indexOf('=')
        if (pos1 > 0) {
            var pos2 = checkProperty.indexOf('.', pos1)
            if (pos2 > pos1)
                checkProperty = checkProperty.substring(0, pos1) + checkProperty.substring(pos2)
        }
        var innerProperty = null as String
        pos1 = checkProperty.indexOf('.')
        if (pos1 > 0) {
            innerProperty = checkProperty.substring(pos1 + 1)
            checkProperty = checkProperty.substring(0, pos1)
        }
        val _checkProperty = checkProperty
        var innerDesriptor = descriptors.findFirst[descriptor |
            descriptor.name == _checkProperty
        ]
        if (innerDesriptor == null) {
            val clazz = pojoResolverFactory.getPojoResolver().loadClass(className, uri)
            if (clazz != null && Modifier.isAbstract(clazz.getModifiers()))
                return ValidationResult.WARNING
            return ValidationResult.ERROR
        }
        if (innerProperty != null) {
            var innerClass = innerDesriptor.getPropertyType()
            if (innerClass.isArray()) {
                val type = innerDesriptor.getReadMethod().getGenericReturnType() as ParameterizedType
                if (type.getActualTypeArguments() == null || type.getActualTypeArguments().length == 0)
                    return ValidationResult.WARNING
                innerClass = type.getActualTypeArguments().head as Class<?>
                if (isPrimitive(innerClass))
                    return ValidationResult.ERROR
                return checkClassProperty(innerClass.getName(), innerProperty, uri)
            } else if (typeof(Collection).isAssignableFrom(innerClass)) {
                val type = innerDesriptor.getReadMethod().getGenericReturnType() as ParameterizedType
                if (type.getActualTypeArguments() == null || type.getActualTypeArguments().length == 0)
                    return ValidationResult.WARNING
                innerClass = type.getActualTypeArguments().head as Class<?>
                if (isPrimitive(innerClass))
                    return ValidationResult.ERROR
                return checkClassProperty(innerClass.getName(), innerProperty, uri)
            } else {
                if (isPrimitive(innerClass))
                    return ValidationResult.ERROR
                return checkClassProperty(innerClass.getName(), innerProperty, uri)
            }
        }
        return ValidationResult.OK
    }

    @Check
    def checkUniqueProperty(Property property) {
        if (CommonUtils.skipVerification(property, modelProperty))
            return;
        val artifacts = getArtifacts(property)
        if (artifacts == null)
            return;

        for (Property prop : artifacts.getProperties()) {
            if (prop != null && prop !== property) {
	            if (prop.getName().equals(property.getName()) && !prop.getName().startsWith("pojogen")
	                    && !prop.getName().startsWith("database") && !prop.getName().startsWith("metagen")
	                    && !prop.getName().startsWith("daogen") && !prop.getName().startsWith("replace-text")) {
	                error("Duplicate name : " + property.getName(), ProcessorMetaPackage.Literals.PROPERTY__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkTableDefinition(TableDefinitionModel tableDefinition) {
        if (CommonUtils.skipVerification(tableDefinition, modelProperty))
            return;
        val artifacts = getArtifacts(tableDefinition)
        if (artifacts == null)
            return;

        for (TableDefinitionModel table : artifacts.getTables()) {
            if (table != null && table !== tableDefinition) {
	            if (tableDefinition.getName().equals(table.getName())) {
	                error("Duplicate name : " + tableDefinition.getName() + "[table]",
	                        ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__NAME)
	                return
				}
	           }
        }
        if (isResolveDb(tableDefinition) && !dbResolver.checkTable(tableDefinition, tableDefinition.getTable())) {
            error("Cannot find table in DB : " + tableDefinition.getTable(),
                    ProcessorMetaPackage.Literals.TABLE_DEFINITION_MODEL__TABLE)
        }
    }

    @Check
    def checkProcedureDefinition(ProcedureDefinitionModel procedureDefinition) {
        if (CommonUtils.skipVerification(procedureDefinition, modelProperty))
            return;
        val artifacts = getArtifacts(procedureDefinition)
        if (artifacts == null)
            return;

        for (ProcedureDefinitionModel procedure : artifacts.getProcedures()) {
            if (procedure != null && procedure !== procedureDefinition) {
	            if (procedureDefinition.getName().equals(procedure.getName())) {
	                error("Duplicate name : " + procedureDefinition.getName() + "[procedure]",
	                        ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME)
	                return
	            }
	        }
        }
        if (isResolveDb(procedureDefinition)
                && !dbResolver.checkProcedure(procedureDefinition, procedureDefinition.getTable())) {
            error("Cannot find procedure in DB : " + procedureDefinition.getTable(),
                    ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME)
        }
    }

    @Check
    def checkFunctionDefinition(FunctionDefinitionModel functionDefinition) {
        if (CommonUtils.skipVerification(functionDefinition, modelProperty))
            return;
        val artifacts = getArtifacts(functionDefinition)
        if (artifacts == null)
            return;

        for (FunctionDefinitionModel function : artifacts.getFunctions()) {
            if (function != null && function !== functionDefinition) {
	            if (functionDefinition.getName().equals(function.getName())) {
	                error("Duplicate name : " + functionDefinition.getName() + "[function]",
	                        ProcessorMetaPackage.Literals.FUNCTION_DEFINITION_MODEL__NAME)
	                return
	            }
	    	}
        }
    }

    @Check
    def checkDatabaseColumn(DatabaseColumn databaseColumn) {
        if (!isResolveDb(databaseColumn))
            return;
        if (CommonUtils.skipVerification(databaseColumn, modelProperty))
            return;
            
        var prefix = databaseColumn.getName()
        var columnName = null as String
        val pos = prefix.indexOf('.')
        if (pos > 0) {
            prefix = databaseColumn.getName().substring(0, pos)
            columnName = databaseColumn.getName().substring(pos + 1)
        } else {
            prefix = null
            columnName = databaseColumn.getName()
        }

        val statement = databaseColumn.getContainerOfType(typeof(MetaStatement))
        val artifacts = getArtifacts(statement)
        if (artifacts == null)
            return;

        val value = Utils.getTokenFromModifier(statement, TABLE_USAGE, prefix)
        val tableDefinition = if (value != null) modelProperty.getModelTables(artifacts).get(value)
        val tableName = if (tableDefinition != null) tableDefinition.getTable()
        if (tableName == null || !dbResolver.checkColumn(databaseColumn, tableName, columnName)) {
            error("Cannot find column in DB : " + databaseColumn.getName() + "[" + tableName + "]",
                    ProcessorMetaPackage.Literals.DATABASE_COLUMN__NAME)
        }
    }

    @Check
    def checkDatabaseTable(DatabaseTable databaseTable) {
        if (!isResolveDb(databaseTable))
            return;
        if (CommonUtils.skipVerification(databaseTable, modelProperty))
            return;

        val statement = databaseTable.getContainerOfType(typeof(MetaStatement))
        val artifacts = getArtifacts(statement)
        if (artifacts == null)
            return;

        val tableName = databaseTable.getName()
        val tableDefinitions = Utils.getTokensFromModifier(statement, TABLE_USAGE).map[value |
        	modelProperty.getModelTables(artifacts).get(value)
        ]
        val tableDefinition = tableDefinitions.findFirst[it != null] 
        if (tableDefinition == null || !dbResolver.checkTable(databaseTable, tableName)) {
            error("Cannot find table in DB : " + tableName, ProcessorMetaPackage.Literals.DATABASE_TABLE__NAME)
        }
    }
    
    def Artifacts getArtifacts(EObject model) {
        val root = model.rootContainer
        if (!(root instanceof Artifacts))
            return null;
        return root as Artifacts
    }
}
