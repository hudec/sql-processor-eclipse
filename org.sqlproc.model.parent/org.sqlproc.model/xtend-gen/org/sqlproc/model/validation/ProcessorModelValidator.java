/**
 * generated by Xtext
 */
package org.sqlproc.model.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.sqlproc.model.processorModel.AbstractEntity;
import org.sqlproc.model.processorModel.AnnotatedEntity;
import org.sqlproc.model.processorModel.AnnotatedFeature;
import org.sqlproc.model.processorModel.AnnotationDefinitionModel;
import org.sqlproc.model.processorModel.Artifacts;
import org.sqlproc.model.processorModel.DaoEntity;
import org.sqlproc.model.processorModel.Entity;
import org.sqlproc.model.processorModel.Feature;
import org.sqlproc.model.processorModel.FunctionDefinitionModel;
import org.sqlproc.model.processorModel.PojoDefinitionModel;
import org.sqlproc.model.processorModel.PojoEntity;
import org.sqlproc.model.processorModel.ProcedureDefinitionModel;
import org.sqlproc.model.processorModel.ProcessorModelPackage;
import org.sqlproc.model.processorModel.Property;
import org.sqlproc.model.processorModel.TableDefinitionModel;
import org.sqlproc.model.validation.AbstractProcessorModelValidator;
import org.sqlproc.plugin.lib.property.ModelProperty;
import org.sqlproc.plugin.lib.resolver.DbResolver;
import org.sqlproc.plugin.lib.util.CommonUtils;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class ProcessorModelValidator extends AbstractProcessorModelValidator {
  @Inject
  private DbResolver dbResolver;
  
  @Inject
  private ModelProperty modelProperty;
  
  @Check
  public void checkUniquePojoDefinition(final PojoDefinitionModel pojoDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(pojoDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(pojoDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<PojoDefinitionModel> _pojos = artifacts.getPojos();
    for (final PojoDefinitionModel definition : _pojos) {
      boolean _and = false;
      boolean _and_1 = false;
      boolean _notEquals = (!Objects.equal(definition, null));
      if (!_notEquals) {
        _and_1 = false;
      } else {
        _and_1 = (definition != pojoDefinition);
      }
      if (!_and_1) {
        _and = false;
      } else {
        String _name = pojoDefinition.getName();
        String _name_1 = definition.getName();
        boolean _equals_1 = Objects.equal(_name, _name_1);
        _and = _equals_1;
      }
      if (_and) {
        String _name_2 = pojoDefinition.getName();
        String _plus = ("Duplicate name : " + _name_2);
        this.error(_plus, ProcessorModelPackage.Literals.POJO_DEFINITION_MODEL__NAME);
        return;
      }
    }
  }
  
  @Check
  public void checkUniqueAnnotationDefinition(final AnnotationDefinitionModel annotationDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(annotationDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(annotationDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<AnnotationDefinitionModel> _annotations = artifacts.getAnnotations();
    for (final AnnotationDefinitionModel definition : _annotations) {
      boolean _and = false;
      boolean _and_1 = false;
      boolean _notEquals = (!Objects.equal(definition, null));
      if (!_notEquals) {
        _and_1 = false;
      } else {
        _and_1 = (definition != annotationDefinition);
      }
      if (!_and_1) {
        _and = false;
      } else {
        String _name = annotationDefinition.getName();
        String _name_1 = definition.getName();
        boolean _equals_1 = Objects.equal(_name, _name_1);
        _and = _equals_1;
      }
      if (_and) {
        String _name_2 = annotationDefinition.getName();
        String _plus = ("Duplicate name : " + _name_2);
        this.error(_plus, ProcessorModelPackage.Literals.ANNOTATION_DEFINITION_MODEL__NAME);
        return;
      }
    }
  }
  
  @Check
  public void checkUniqueProperty(final Property property) {
    boolean _skipVerification = CommonUtils.skipVerification(property, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(property);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<Property> _properties = artifacts.getProperties();
    for (final Property prop : _properties) {
      boolean _and = false;
      boolean _and_1 = false;
      boolean _notEquals = (!Objects.equal(prop, null));
      if (!_notEquals) {
        _and_1 = false;
      } else {
        _and_1 = (prop != property);
      }
      if (!_and_1) {
        _and = false;
      } else {
        String _name = prop.getName();
        String _name_1 = property.getName();
        boolean _equals_1 = Objects.equal(_name, _name_1);
        _and = _equals_1;
      }
      if (_and) {
        boolean _and_2 = false;
        boolean _and_3 = false;
        boolean _and_4 = false;
        boolean _and_5 = false;
        String _name_2 = prop.getName();
        boolean _startsWith = _name_2.startsWith("pojogen");
        boolean _not = (!_startsWith);
        if (!_not) {
          _and_5 = false;
        } else {
          String _name_3 = prop.getName();
          boolean _startsWith_1 = _name_3.startsWith("database");
          boolean _not_1 = (!_startsWith_1);
          _and_5 = _not_1;
        }
        if (!_and_5) {
          _and_4 = false;
        } else {
          String _name_4 = prop.getName();
          boolean _startsWith_2 = _name_4.startsWith("metagen");
          boolean _not_2 = (!_startsWith_2);
          _and_4 = _not_2;
        }
        if (!_and_4) {
          _and_3 = false;
        } else {
          String _name_5 = prop.getName();
          boolean _startsWith_3 = _name_5.startsWith("daogen");
          boolean _not_3 = (!_startsWith_3);
          _and_3 = _not_3;
        }
        if (!_and_3) {
          _and_2 = false;
        } else {
          String _name_6 = prop.getName();
          boolean _startsWith_4 = _name_6.startsWith("replace-text");
          boolean _not_4 = (!_startsWith_4);
          _and_2 = _not_4;
        }
        if (_and_2) {
          String _name_7 = property.getName();
          String _plus = ("Duplicate name : " + _name_7);
          this.error(_plus, ProcessorModelPackage.Literals.PROPERTY__NAME);
          return;
        }
      }
    }
  }
  
  @Check
  public void checkTableDefinition(final TableDefinitionModel tableDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(tableDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(tableDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<TableDefinitionModel> _tables = artifacts.getTables();
    for (final TableDefinitionModel table : _tables) {
      boolean _and = false;
      boolean _and_1 = false;
      boolean _notEquals = (!Objects.equal(table, null));
      if (!_notEquals) {
        _and_1 = false;
      } else {
        _and_1 = (table != tableDefinition);
      }
      if (!_and_1) {
        _and = false;
      } else {
        String _name = tableDefinition.getName();
        String _name_1 = table.getName();
        boolean _equals_1 = Objects.equal(_name, _name_1);
        _and = _equals_1;
      }
      if (_and) {
        String _name_2 = tableDefinition.getName();
        String _plus = ("Duplicate name : " + _name_2);
        String _plus_1 = (_plus + "[table]");
        this.error(_plus_1, ProcessorModelPackage.Literals.TABLE_DEFINITION_MODEL__NAME);
        return;
      }
    }
    boolean _and_2 = false;
    boolean _isResolveDb = this.isResolveDb(tableDefinition);
    if (!_isResolveDb) {
      _and_2 = false;
    } else {
      String _table = tableDefinition.getTable();
      boolean _checkTable = this.dbResolver.checkTable(tableDefinition, _table);
      boolean _not = (!_checkTable);
      _and_2 = _not;
    }
    if (_and_2) {
      String _table_1 = tableDefinition.getTable();
      String _plus_2 = ("Cannot find table in DB : " + _table_1);
      this.error(_plus_2, ProcessorModelPackage.Literals.TABLE_DEFINITION_MODEL__TABLE);
    }
  }
  
  @Check
  public void checkProcedureDefinition(final ProcedureDefinitionModel procedureDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(procedureDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(procedureDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<ProcedureDefinitionModel> _procedures = artifacts.getProcedures();
    for (final ProcedureDefinitionModel procedure : _procedures) {
      boolean _and = false;
      boolean _and_1 = false;
      boolean _notEquals = (!Objects.equal(procedure, null));
      if (!_notEquals) {
        _and_1 = false;
      } else {
        _and_1 = (procedure != procedureDefinition);
      }
      if (!_and_1) {
        _and = false;
      } else {
        String _name = procedureDefinition.getName();
        String _name_1 = procedure.getName();
        boolean _equals_1 = Objects.equal(_name, _name_1);
        _and = _equals_1;
      }
      if (_and) {
        String _name_2 = procedureDefinition.getName();
        String _plus = ("Duplicate name : " + _name_2);
        String _plus_1 = (_plus + "[procedure]");
        this.error(_plus_1, ProcessorModelPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME);
        return;
      }
    }
    boolean _and_2 = false;
    boolean _isResolveDb = this.isResolveDb(procedureDefinition);
    if (!_isResolveDb) {
      _and_2 = false;
    } else {
      String _table = procedureDefinition.getTable();
      boolean _checkProcedure = this.dbResolver.checkProcedure(procedureDefinition, _table);
      boolean _not = (!_checkProcedure);
      _and_2 = _not;
    }
    if (_and_2) {
      String _table_1 = procedureDefinition.getTable();
      String _plus_2 = ("Cannot find procedure in DB : " + _table_1);
      this.error(_plus_2, ProcessorModelPackage.Literals.PROCEDURE_DEFINITION_MODEL__NAME);
    }
  }
  
  @Check
  public void checkFunctionDefinition(final FunctionDefinitionModel functionDefinition) {
    boolean _skipVerification = CommonUtils.skipVerification(functionDefinition, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(functionDefinition);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<FunctionDefinitionModel> _functions = artifacts.getFunctions();
    for (final FunctionDefinitionModel function : _functions) {
      boolean _and = false;
      boolean _and_1 = false;
      boolean _notEquals = (!Objects.equal(function, null));
      if (!_notEquals) {
        _and_1 = false;
      } else {
        _and_1 = (function != functionDefinition);
      }
      if (!_and_1) {
        _and = false;
      } else {
        String _name = functionDefinition.getName();
        String _name_1 = function.getName();
        boolean _equals_1 = Objects.equal(_name, _name_1);
        _and = _equals_1;
      }
      if (_and) {
        String _name_2 = functionDefinition.getName();
        String _plus = ("Duplicate name : " + _name_2);
        String _plus_1 = (_plus + "[function]");
        this.error(_plus_1, ProcessorModelPackage.Literals.FUNCTION_DEFINITION_MODEL__NAME);
        return;
      }
    }
  }
  
  @Check
  public void checkUniquePojoEntity(final Entity entity) {
    boolean _skipVerification = CommonUtils.skipVerification(entity, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Artifacts artifacts = this.getArtifacts(entity);
    boolean _equals = Objects.equal(artifacts, null);
    if (_equals) {
      return;
    }
    EList<org.sqlproc.model.processorModel.Package> _packages = artifacts.getPackages();
    for (final org.sqlproc.model.processorModel.Package pkg : _packages) {
      boolean _notEquals = (!Objects.equal(pkg, null));
      if (_notEquals) {
        EList<AbstractEntity> _elements = pkg.getElements();
        for (final AbstractEntity abstractEntity : _elements) {
          boolean _and = false;
          boolean _notEquals_1 = (!Objects.equal(abstractEntity, null));
          if (!_notEquals_1) {
            _and = false;
          } else {
            _and = (abstractEntity instanceof AnnotatedEntity);
          }
          if (_and) {
            final AnnotatedEntity annotatedEntity = ((AnnotatedEntity) abstractEntity);
            Entity _entity = annotatedEntity.getEntity();
            boolean _notEquals_2 = (!Objects.equal(_entity, null));
            if (_notEquals_2) {
              Entity _entity_1 = annotatedEntity.getEntity();
              final Entity _entity_2 = ((Entity) _entity_1);
              boolean _and_1 = false;
              boolean _and_2 = false;
              boolean _notEquals_3 = (!Objects.equal(_entity_2, null));
              if (!_notEquals_3) {
                _and_2 = false;
              } else {
                _and_2 = (_entity_2 != entity);
              }
              if (!_and_2) {
                _and_1 = false;
              } else {
                String _name = entity.getName();
                String _name_1 = _entity_2.getName();
                boolean _equals_1 = Objects.equal(_name, _name_1);
                _and_1 = _equals_1;
              }
              if (_and_1) {
                String _name_2 = entity.getName();
                String _plus = ("Duplicate name : " + _name_2);
                this.error(_plus, ProcessorModelPackage.Literals.ENTITY__NAME);
                return;
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkUniquePojoAttribute(final Feature feature) {
    boolean _skipVerification = CommonUtils.skipVerification(feature, this.modelProperty);
    if (_skipVerification) {
      return;
    }
    final Entity entity = EcoreUtil2.<Entity>getContainerOfType(feature, Entity.class);
    boolean _notEquals = (!Objects.equal(entity, null));
    if (_notEquals) {
      if ((entity instanceof PojoEntity)) {
        final PojoEntity pentity = ((PojoEntity) entity);
        EList<AnnotatedFeature> _features = pentity.getFeatures();
        final Function1<AnnotatedFeature, Feature> _function = new Function1<AnnotatedFeature, Feature>() {
          @Override
          public Feature apply(final AnnotatedFeature it) {
            return feature;
          }
        };
        List<Feature> _map = ListExtensions.<AnnotatedFeature, Feature>map(_features, _function);
        for (final Feature _feature : _map) {
          boolean _and = false;
          boolean _and_1 = false;
          boolean _notEquals_1 = (!Objects.equal(_feature, null));
          if (!_notEquals_1) {
            _and_1 = false;
          } else {
            _and_1 = (_feature != feature);
          }
          if (!_and_1) {
            _and = false;
          } else {
            String _name = feature.getName();
            String _name_1 = _feature.getName();
            boolean _equals = Objects.equal(_name, _name_1);
            _and = _equals;
          }
          if (_and) {
            String _name_2 = feature.getName();
            String _plus = ("Duplicate name : " + _name_2);
            this.error(_plus, ProcessorModelPackage.Literals.FEATURE__NAME);
            return;
          }
        }
      } else {
        if ((entity instanceof DaoEntity)) {
          final DaoEntity pentity_1 = ((DaoEntity) entity);
          EList<AnnotatedFeature> _features_1 = pentity_1.getFeatures();
          final Function1<AnnotatedFeature, Feature> _function_1 = new Function1<AnnotatedFeature, Feature>() {
            @Override
            public Feature apply(final AnnotatedFeature it) {
              return feature;
            }
          };
          List<Feature> _map_1 = ListExtensions.<AnnotatedFeature, Feature>map(_features_1, _function_1);
          for (final Feature _feature_1 : _map_1) {
            boolean _and_2 = false;
            boolean _and_3 = false;
            boolean _notEquals_2 = (!Objects.equal(_feature_1, null));
            if (!_notEquals_2) {
              _and_3 = false;
            } else {
              _and_3 = (_feature_1 != feature);
            }
            if (!_and_3) {
              _and_2 = false;
            } else {
              String _name_3 = feature.getName();
              String _name_4 = _feature_1.getName();
              boolean _equals_1 = Objects.equal(_name_3, _name_4);
              _and_2 = _equals_1;
            }
            if (_and_2) {
              String _name_5 = feature.getName();
              String _plus_1 = ("Duplicate name : " + _name_5);
              this.error(_plus_1, ProcessorModelPackage.Literals.FEATURE__NAME);
              return;
            }
          }
        }
      }
    }
  }
  
  public boolean isResolveDb(final EObject model) {
    return this.dbResolver.isResolveDb(model);
  }
  
  public Artifacts getArtifacts(final EObject model) {
    final EObject root = EcoreUtil.getRootContainer(model);
    if ((!(root instanceof Artifacts))) {
      return null;
    }
    return ((Artifacts) root);
  }
}
